"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getAddMissingImportsEdits = void 0;
const shared = require("@volar/shared");
const scriptSetupConvertRanges_1 = require("@volar/vue-code-gen/out/parsers/scriptSetupConvertRanges");
const vscode = require("vscode-languageserver-protocol");
const vue_language_service_types_1 = require("@volar/vue-language-service-types");
var Commands;
(function (Commands) {
    Commands["USE_SETUP_SUGAR"] = "scriptSetupConversions.use";
    Commands["UNUSE_SETUP_SUGAR"] = "scriptSetupConversions.unuse";
})(Commands || (Commands = {}));
function default_1(options) {
    return {
        codeLens: {
            on(document) {
                return worker(document.uri, (vueDocument) => __awaiter(this, void 0, void 0, function* () {
                    var _a, _b;
                    const isEnabled = (_b = yield ((_a = (0, vue_language_service_types_1.useConfigurationHost)()) === null || _a === void 0 ? void 0 : _a.getConfiguration('volar.codeLens.scriptSetupTools'))) !== null && _b !== void 0 ? _b : true;
                    if (!isEnabled)
                        return;
                    const result = [];
                    const descriptor = vueDocument.file.getDescriptor();
                    if (descriptor.scriptSetup) {
                        result.push({
                            range: {
                                start: document.positionAt(descriptor.scriptSetup.startTagEnd),
                                end: document.positionAt(descriptor.scriptSetup.startTagEnd + descriptor.scriptSetup.content.length),
                            },
                            command: {
                                title: 'setup sugar ☑',
                                command: Commands.UNUSE_SETUP_SUGAR,
                                arguments: [document.uri],
                            },
                        });
                    }
                    else if (descriptor.script) {
                        result.push({
                            range: {
                                start: document.positionAt(descriptor.script.startTagEnd),
                                end: document.positionAt(descriptor.script.startTagEnd + descriptor.script.content.length),
                            },
                            command: {
                                title: 'setup sugar ☐',
                                command: Commands.USE_SETUP_SUGAR,
                                arguments: [document.uri],
                            },
                        });
                    }
                    return result;
                }));
            },
        },
        doExecuteCommand(command, args, context) {
            if (command === Commands.USE_SETUP_SUGAR) {
                const [uri] = args;
                return worker(uri, vueDocument => {
                    return useSetupSugar(options.ts, vueDocument, context, options.doCodeActions, options.doCodeActionResolve);
                });
            }
            if (command === Commands.UNUSE_SETUP_SUGAR) {
                const [uri] = args;
                return worker(uri, vueDocument => {
                    return unuseSetupSugar(options.ts, vueDocument, context, options.doCodeActions, options.doCodeActionResolve);
                });
            }
        },
    };
    function worker(uri, callback) {
        const vueDocument = options.getVueDocument(uri);
        if (!vueDocument)
            return;
        return callback(vueDocument);
    }
}
exports.default = default_1;
function useSetupSugar(ts, vueDocument, context, doCodeActions, doCodeActionResolve) {
    return __awaiter(this, void 0, void 0, function* () {
        const descriptor = vueDocument.file.getDescriptor();
        if (!descriptor.script)
            return;
        const scriptAst = vueDocument.file.getScriptAst();
        if (!scriptAst)
            return;
        const edits = yield getEdits(vueDocument, descriptor.script, scriptAst);
        if (edits === null || edits === void 0 ? void 0 : edits.length) {
            yield context.applyEdit({ changes: { [vueDocument.uri]: edits } });
            yield shared.sleep(200);
            const importEdits = yield getAddMissingImportsEdits(vueDocument, doCodeActions, doCodeActionResolve);
            if (importEdits) {
                yield context.applyEdit(importEdits);
            }
        }
        function getEdits(_vueDocument, _script, _scriptAst) {
            return __awaiter(this, void 0, void 0, function* () {
                const ranges = (0, scriptSetupConvertRanges_1.parseUseScriptSetupRanges)(ts, _scriptAst);
                const document = _vueDocument.getDocument();
                const edits = [];
                const scriptStartPos = document.positionAt(_script.startTagEnd);
                const startTagText = document.getText({
                    start: {
                        line: scriptStartPos.line,
                        character: 0,
                    },
                    end: scriptStartPos,
                });
                addReplace(-1, -1, ' setup');
                const newScriptSetupCode = getScriptSetupCode();
                const newScriptCode = getScriptCode();
                addReplace(0, _script.content.length, '\n' + newScriptSetupCode + '\n');
                if (newScriptCode !== '') {
                    let newScriptBlock = `${startTagText}\n${newScriptCode}\n</script>\n\n`;
                    addReplace(-startTagText.length, -startTagText.length, newScriptBlock);
                }
                return edits;
                function getScriptCode() {
                    let scriptBodyCode = '';
                    let scriptExportCode = '';
                    for (const statement of ranges.otherScriptStatements) {
                        const statementRange = getStatementRange(statement);
                        scriptBodyCode += _script.content.substring(statementRange.start, statementRange.end) + '\n';
                    }
                    if (ranges.otherOptions.length) {
                        scriptExportCode += 'export default {\n';
                        for (const otherOption of ranges.otherOptions) {
                            scriptExportCode += _script.content.substring(otherOption.start, otherOption.end) + ',\n';
                        }
                        scriptExportCode += '};\n';
                    }
                    return [scriptBodyCode, scriptExportCode]
                        .map(code => code.trim())
                        .filter(code => code !== '')
                        .join('\n\n');
                }
                function getScriptSetupCode() {
                    var _a, _b, _c, _d, _e;
                    let scriptSetupImportsCode = '';
                    let scriptDefinesCode = '';
                    let scriptSetupBodyCode = '';
                    for (const importRange of ranges.imports) {
                        let importRange_2 = getStatementRange(importRange);
                        scriptSetupImportsCode += _script.content.substring(importRange_2.start, importRange_2.end) + '\n';
                    }
                    if (ranges.propsOption) {
                        if ((_a = ranges.setupOption) === null || _a === void 0 ? void 0 : _a.props) {
                            scriptDefinesCode += `const ${_script.content.substring(ranges.setupOption.props.start, ranges.setupOption.props.end)} = `;
                        }
                        scriptDefinesCode += `defineProps(${_script.content.substring(ranges.propsOption.start, ranges.propsOption.end)});\n`;
                    }
                    if (((_b = ranges.setupOption) === null || _b === void 0 ? void 0 : _b.context) && 'start' in ranges.setupOption.context) {
                        scriptDefinesCode += `const ${_script.content.substring(ranges.setupOption.context.start, ranges.setupOption.context.end)} = {\n`;
                        if (ranges.emitsOption) {
                            scriptDefinesCode += `emit: defineEmits(${_script.content.substring(ranges.emitsOption.start, ranges.emitsOption.end)}),\n`;
                        }
                        scriptDefinesCode += `slots: useSlots(),\n`;
                        scriptDefinesCode += `attrs: useAttrs(),\n`;
                        scriptDefinesCode += '};\n';
                    }
                    else {
                        if (ranges.emitsOption) {
                            if (((_c = ranges.setupOption) === null || _c === void 0 ? void 0 : _c.context) && 'emit' in ranges.setupOption.context && ranges.setupOption.context.emit) {
                                scriptDefinesCode += `const ${_script.content.substring(ranges.setupOption.context.emit.start, ranges.setupOption.context.emit.end)} = `;
                            }
                            scriptDefinesCode += `defineEmits(${_script.content.substring(ranges.emitsOption.start, ranges.emitsOption.end)});\n`;
                        }
                        if (((_d = ranges.setupOption) === null || _d === void 0 ? void 0 : _d.context) && 'slots' in ranges.setupOption.context && ranges.setupOption.context.slots) {
                            scriptDefinesCode += `const ${_script.content.substring(ranges.setupOption.context.slots.start, ranges.setupOption.context.slots.end)} = useSlots();\n`;
                        }
                        if (((_e = ranges.setupOption) === null || _e === void 0 ? void 0 : _e.context) && 'attrs' in ranges.setupOption.context && ranges.setupOption.context.attrs) {
                            scriptDefinesCode += `const ${_script.content.substring(ranges.setupOption.context.attrs.start, ranges.setupOption.context.attrs.end)} = useAttrs();\n`;
                        }
                    }
                    if (ranges.setupOption) {
                        const bodyRange = {
                            start: ranges.setupOption.body.start + 1,
                            end: ranges.setupOption.body.end - 1, // remove }
                        };
                        if (ranges.setupOption.bodyReturn) {
                            const reutrnRange = getStatementRange(ranges.setupOption.bodyReturn);
                            scriptSetupBodyCode = _script.content.substring(bodyRange.start, reutrnRange.start)
                                + _script.content.substring(reutrnRange.end, bodyRange.end);
                        }
                        else {
                            scriptSetupBodyCode = _script.content.substring(bodyRange.start, bodyRange.end);
                        }
                    }
                    return [scriptSetupImportsCode, scriptDefinesCode, scriptSetupBodyCode]
                        .map(code => code.trim())
                        .filter(code => code !== '')
                        .join('\n\n');
                }
                function getStatementRange(scriptTextRange) {
                    let end = scriptTextRange.end;
                    if (_script.content.substring(end, end + 1) === ';')
                        end++;
                    return {
                        start: scriptTextRange.start,
                        end,
                    };
                }
                function addReplace(start, end, text) {
                    edits.push(vscode.TextEdit.replace({
                        start: document.positionAt(_script.startTagEnd + start),
                        end: document.positionAt(_script.startTagEnd + end),
                    }, text));
                }
            });
        }
    });
}
function unuseSetupSugar(ts, vueDocument, context, doCodeActions, doCodeActionResolve) {
    return __awaiter(this, void 0, void 0, function* () {
        const descriptor = vueDocument.file.getDescriptor();
        if (!descriptor.scriptSetup)
            return;
        const scriptSetupAst = vueDocument.file.getScriptSetupAst();
        if (!scriptSetupAst)
            return;
        const edits = yield getEdits(vueDocument, descriptor.script, descriptor.scriptSetup, vueDocument.file.getScriptAst(), scriptSetupAst);
        if (edits === null || edits === void 0 ? void 0 : edits.length) {
            yield context.applyEdit({ changes: { [vueDocument.uri]: edits } });
            yield shared.sleep(200);
            const importEdits = yield getAddMissingImportsEdits(vueDocument);
            if (importEdits) {
                yield context.applyEdit(importEdits);
            }
        }
        function getAddMissingImportsEdits(_vueDocument) {
            var _a;
            return __awaiter(this, void 0, void 0, function* () {
                const document = _vueDocument.getDocument();
                const codeActions = (_a = yield doCodeActions(document.uri, {
                    start: document.positionAt(0),
                    end: document.positionAt(document.getText().length),
                }, {
                    diagnostics: [],
                    only: [`${vscode.CodeActionKind.Source}.addMissingImports.ts`],
                })) !== null && _a !== void 0 ? _a : [];
                for (const codeAction of codeActions) {
                    const newCodeAction = yield doCodeActionResolve(codeAction);
                    if (newCodeAction.edit) {
                        return newCodeAction.edit;
                    }
                }
            });
        }
        function getEdits(_vueDocument, _script, _scriptSetup, _scriptAst, _scriptSetupAst) {
            var _a, _b, _c, _d;
            return __awaiter(this, void 0, void 0, function* () {
                const ranges = (0, scriptSetupConvertRanges_1.parseUnuseScriptSetupRanges)(ts, _scriptSetupAst);
                const scriptRanges = _scriptAst ? (0, scriptSetupConvertRanges_1.parseUseScriptSetupRanges)(ts, _scriptAst) : undefined;
                const document = _vueDocument.getDocument();
                const edits = [];
                const removeSetupTextRanges = [...ranges.imports];
                const sfcCode = document.getText();
                const setupAttr = sfcCode.substring(0, _scriptSetup.startTagEnd).lastIndexOf(' setup');
                edits.push(vscode.TextEdit.replace({
                    start: document.positionAt(setupAttr),
                    end: document.positionAt(setupAttr + ' setup'.length),
                }, ''));
                if (_script) {
                    edits.push(vscode.TextEdit.replace({
                        start: document.positionAt(_script.start),
                        end: document.positionAt(_script.end),
                    }, ''));
                }
                if (ranges.defineProps) {
                    removeSetupTextRanges.push(ranges.defineProps.range);
                }
                if (ranges.defineEmits) {
                    removeSetupTextRanges.push(ranges.defineEmits.range);
                }
                if (ranges.useSlots) {
                    removeSetupTextRanges.push(ranges.useSlots.range);
                }
                if (ranges.useAttrs) {
                    removeSetupTextRanges.push(ranges.useAttrs.range);
                }
                let newScriptCode = '';
                for (const setupImport of ranges.imports) {
                    newScriptCode += _scriptSetup.content.substring(setupImport.start, setupImport.end);
                    newScriptCode += '\n';
                }
                if (_script) {
                    if (scriptRanges === null || scriptRanges === void 0 ? void 0 : scriptRanges.exportDefault) {
                        let scriptCodeWithoutExport = _script.content.substring(0, scriptRanges.exportDefault.start).trim() + '\n'
                            + _script.content.substring(scriptRanges.exportDefault.end).trim();
                        scriptCodeWithoutExport = scriptCodeWithoutExport.trim();
                        if (scriptCodeWithoutExport) {
                            newScriptCode += '\n' + scriptCodeWithoutExport + '\n';
                        }
                    }
                    else {
                        newScriptCode += _script.content;
                    }
                }
                newScriptCode += '\n';
                newScriptCode += 'export default defineComponent({\n';
                if (scriptRanges && _script) {
                    for (const otherOption of scriptRanges.otherOptions) {
                        newScriptCode += _script.content.substring(otherOption.start, otherOption.end) + ',\n';
                    }
                }
                if (ranges.defineProps && 'args' in ranges.defineProps) {
                    newScriptCode += 'props: ';
                    newScriptCode += _scriptSetup.content.substring(ranges.defineProps.args.start, ranges.defineProps.args.end);
                    newScriptCode += ',\n';
                }
                if (ranges.defineProps && 'typeArgs' in ranges.defineProps) {
                    newScriptCode += 'props: {\n';
                    for (const typeProp of ranges.defineProps.typeArgs) {
                        const nameString = _scriptSetup.content.substring(typeProp.name.start, typeProp.name.end);
                        const typeString = getTypeObject(typeProp.type);
                        if (!typeProp.required && !typeProp.default) {
                            newScriptCode += `${nameString}: ${typeString},\n`;
                        }
                        else {
                            newScriptCode += `${nameString}: {\n`;
                            newScriptCode += `type: ${typeString},\n`;
                            if (typeProp.required) {
                                newScriptCode += `required: true,\n`;
                            }
                            if (typeProp.default) {
                                newScriptCode += `default: ${_scriptSetup.content.substring(typeProp.default.start, typeProp.default.end)},\n`;
                            }
                            newScriptCode += '},\n';
                        }
                    }
                    newScriptCode += '},\n';
                }
                if (ranges.defineEmits && 'args' in ranges.defineEmits) {
                    newScriptCode += 'emits: ';
                    newScriptCode += _scriptSetup.content.substring(ranges.defineEmits.args.start, ranges.defineEmits.args.end);
                    newScriptCode += ',\n';
                }
                if (ranges.defineEmits && 'typeArgs' in ranges.defineEmits) {
                    newScriptCode += 'emits: {\n';
                    for (const typeProp of ranges.defineEmits.typeArgs) {
                        const nameString = _scriptSetup.content.substring(typeProp.name.start, typeProp.name.end);
                        newScriptCode += `${nameString}: (`;
                        if (typeProp.restArgs) {
                            newScriptCode += _scriptSetup.content.substring(typeProp.restArgs.start, typeProp.restArgs.end);
                        }
                        newScriptCode += `) => true,\n`;
                    }
                    newScriptCode += '},\n';
                }
                {
                    newScriptCode += 'setup(';
                    let addedProps = false;
                    if ((_a = ranges.defineProps) === null || _a === void 0 ? void 0 : _a.binding) {
                        newScriptCode += _scriptSetup.content.substring(ranges.defineProps.binding.start, ranges.defineProps.binding.end);
                        addedProps = true;
                    }
                    const contextProps = [];
                    if ((_b = ranges.defineEmits) === null || _b === void 0 ? void 0 : _b.binding) {
                        contextProps.push(getContextPropText(ranges.defineEmits.binding, 'emit'));
                    }
                    if ((_c = ranges.useSlots) === null || _c === void 0 ? void 0 : _c.binding) {
                        contextProps.push(getContextPropText(ranges.useSlots.binding, 'slots'));
                    }
                    if ((_d = ranges.useAttrs) === null || _d === void 0 ? void 0 : _d.binding) {
                        contextProps.push(getContextPropText(ranges.useAttrs.binding, 'attrs'));
                    }
                    if (contextProps.length) {
                        tryAddProps();
                        newScriptCode += ', { ';
                        newScriptCode += contextProps.join(', ');
                        newScriptCode += ' }';
                    }
                    newScriptCode += ') {\n';
                    newScriptCode += getSetupOptionCode();
                    newScriptCode += '\n';
                    newScriptCode += 'return {\n';
                    for (const binding of ranges.bindings) {
                        newScriptCode += _scriptSetup.content.substring(binding.start, binding.end) + ',\n';
                    }
                    newScriptCode += '};\n';
                    newScriptCode += '},\n';
                    function tryAddProps() {
                        if (!addedProps) {
                            newScriptCode += '_props';
                            addedProps = true;
                        }
                    }
                    function getContextPropText(textSetupRange, defaultName) {
                        const text = _scriptSetup.content.substring(textSetupRange.start, textSetupRange.end);
                        if (text !== defaultName) {
                            return `${defaultName}: ${text}`;
                        }
                        else {
                            return text;
                        }
                    }
                }
                newScriptCode += '});\n';
                addReplace(0, _scriptSetup.content.length, '\n' + newScriptCode.trim() + '\n');
                return edits;
                function getSetupOptionCode() {
                    let text = _scriptSetup.content;
                    for (const range of removeSetupTextRanges.sort((a, b) => b.start - a.start)) {
                        let end = range.end;
                        if (text.substring(end, end + 1) === ';')
                            end++;
                        text = text.substring(0, range.start) + text.substring(end);
                    }
                    return text.trim();
                }
                function getTypeObject(typeSetupRange) {
                    const typeText = _scriptSetup.content.substring(typeSetupRange.start, typeSetupRange.end);
                    switch (typeText) {
                        case 'Function': return 'Function';
                        case 'string': return 'String';
                        case 'boolean': return 'Boolean';
                        case 'number': return 'Number';
                        case 'object': return 'Object';
                    }
                    if (typeText.endsWith(']'))
                        return `Array as PropType<${typeText}>`;
                    if (typeText.endsWith('}'))
                        return `Object as PropType<${typeText}>`;
                    return `null as any as PropType<${typeText}>`;
                }
                function addReplace(start, end, text) {
                    if (_scriptSetup.content.substring(start, end) === text)
                        return;
                    edits.push(vscode.TextEdit.replace({
                        start: document.positionAt(_scriptSetup.startTagEnd + start),
                        end: document.positionAt(_scriptSetup.startTagEnd + end),
                    }, text));
                }
            });
        }
    });
}
function getAddMissingImportsEdits(_vueDocument, doCodeActions, doCodeActionResolve) {
    var _a;
    return __awaiter(this, void 0, void 0, function* () {
        const document = _vueDocument.getDocument();
        const codeActions = (_a = yield doCodeActions(document.uri, {
            start: document.positionAt(0),
            end: document.positionAt(document.getText().length),
        }, {
            diagnostics: [],
            only: [`${vscode.CodeActionKind.Source}.addMissingImports.ts`],
        })) !== null && _a !== void 0 ? _a : [];
        for (const codeAction of codeActions) {
            const newCodeAction = yield doCodeActionResolve(codeAction);
            if (newCodeAction.edit) {
                return newCodeAction.edit;
            }
        }
    });
}
exports.getAddMissingImportsEdits = getAddMissingImportsEdits;
//# sourceMappingURL=vue-convert-scriptsetup.js.map