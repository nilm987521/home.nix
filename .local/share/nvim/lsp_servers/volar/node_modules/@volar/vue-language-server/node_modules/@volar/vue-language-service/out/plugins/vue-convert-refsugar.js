"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const shared = require("@volar/shared");
const refSugarRanges_1 = require("@volar/vue-code-gen/out/parsers/refSugarRanges");
const vscode = require("vscode-languageserver-protocol");
const rename_1 = require("../languageFeatures/rename");
const vue_language_service_types_1 = require("@volar/vue-language-service-types");
const vue_autoinsert_dotvalue_1 = require("./vue-autoinsert-dotvalue");
const vue_convert_scriptsetup_1 = require("./vue-convert-scriptsetup");
var Commands;
(function (Commands) {
    Commands["USE_REF_SUGAR"] = "refSugarConversions.use";
    Commands["UNUSE_REF_SUGAR"] = "refSugarConversions.unuse";
})(Commands || (Commands = {}));
function default_1(options) {
    return {
        codeLens: {
            on(document) {
                return worker(document.uri, (vueDocument) => __awaiter(this, void 0, void 0, function* () {
                    var _a, _b;
                    const isEnabled = (_b = yield ((_a = (0, vue_language_service_types_1.useConfigurationHost)()) === null || _a === void 0 ? void 0 : _a.getConfiguration('volar.codeLens.scriptSetupTools'))) !== null && _b !== void 0 ? _b : true;
                    if (!isEnabled)
                        return;
                    const result = [];
                    const descriptor = vueDocument.file.getDescriptor();
                    const ranges = vueDocument.file.getSfcRefSugarRanges();
                    if (descriptor.scriptSetup && ranges) {
                        result.push({
                            range: {
                                start: document.positionAt(descriptor.scriptSetup.startTagEnd),
                                end: document.positionAt(descriptor.scriptSetup.startTagEnd + descriptor.scriptSetup.content.length),
                            },
                            command: {
                                title: 'ref sugar ' + (ranges.refs.length ? '☑' : '☐'),
                                command: ranges.refs.length ? Commands.UNUSE_REF_SUGAR : Commands.USE_REF_SUGAR,
                                arguments: [document.uri],
                            },
                        });
                    }
                    return result;
                }));
            },
        },
        doExecuteCommand(command, args, context) {
            if (command === Commands.USE_REF_SUGAR) {
                const [uri] = args;
                return worker(uri, vueDocument => {
                    return useRefSugar(options.ts, vueDocument, context, options.findReferences, options.findTypeDefinition, options.scriptTsLs);
                });
            }
            if (command === Commands.UNUSE_REF_SUGAR) {
                const [uri] = args;
                return worker(uri, vueDocument => {
                    return unuseRefSugar(vueDocument, context, options.doCodeActions, options.doCodeActionResolve, options.doRename, options.doValidation);
                });
            }
        },
    };
    function worker(uri, callback) {
        const vueDocument = options.getVueDocument(uri);
        if (!vueDocument)
            return;
        return callback(vueDocument);
    }
}
exports.default = default_1;
function useRefSugar(ts, vueDocument, context, findReferences, findTypeDefinition, scriptTsLs) {
    return __awaiter(this, void 0, void 0, function* () {
        const descriptor = vueDocument.file.getDescriptor();
        if (!descriptor.scriptSetup)
            return;
        const scriptSetupAst = vueDocument.file.getScriptSetupAst();
        if (!scriptSetupAst)
            return;
        context.workDoneProgress.begin('Unuse Ref Sugar', 0, '', true);
        const edits = yield getUseRefSugarEdits(vueDocument, descriptor.scriptSetup, scriptSetupAst);
        if (context.token.isCancellationRequested)
            return;
        if (edits === null || edits === void 0 ? void 0 : edits.length) {
            yield context.applyEdit({ changes: { [vueDocument.uri]: edits } });
        }
        context.workDoneProgress.done();
        function getUseRefSugarEdits(_vueDocument, _scriptSetup, _scriptSetupAst) {
            var _a, _b;
            return __awaiter(this, void 0, void 0, function* () {
                const ranges = (0, refSugarRanges_1.parseDeclarationRanges)(ts, _scriptSetupAst);
                const dotValueRanges = (0, refSugarRanges_1.parseDotValueRanges)(ts, _scriptSetupAst);
                const document = _vueDocument.getDocument();
                const edits = [];
                for (const declaration of ranges) {
                    let isRefDeclaration = false;
                    for (const binding of declaration.leftBindings) {
                        const definitions = (_a = yield findTypeDefinition(document.uri, document.positionAt(_scriptSetup.startTagEnd + binding.end))) !== null && _a !== void 0 ? _a : [];
                        const _isRefType = (0, vue_autoinsert_dotvalue_1.isRefType)(definitions, scriptTsLs);
                        if (!_isRefType)
                            continue;
                        isRefDeclaration = true;
                        let references = (_b = yield findReferences(document.uri, document.positionAt(_scriptSetup.startTagEnd + binding.end))) !== null && _b !== void 0 ? _b : [];
                        references = references.filter(reference => {
                            if (reference.uri !== document.uri)
                                return false;
                            const start = document.offsetAt(reference.range.start);
                            const end = document.offsetAt(reference.range.end);
                            if (start >= (_scriptSetup.startTagEnd + binding.start) && end <= (_scriptSetup.startTagEnd + binding.end))
                                return false;
                            if (end < _scriptSetup.startTagEnd || start > _scriptSetup.startTagEnd + _scriptSetup.content.length)
                                return false;
                            if ((0, vue_autoinsert_dotvalue_1.isBlacklistNode)(ts, _scriptSetupAst, start - _scriptSetup.startTagEnd))
                                return false;
                            return true;
                        });
                        for (const reference of references) {
                            const sfcStart = document.offsetAt(reference.range.start);
                            const sfcEnd = document.offsetAt(reference.range.end);
                            const setupStart = sfcStart - _scriptSetup.startTagEnd;
                            const setupEnd = sfcEnd - _scriptSetup.startTagEnd;
                            const dotValue = dotValueRanges.find(dot => dot.beforeDot === setupEnd);
                            if (!dotValue) {
                                addReplace(setupStart, setupStart, '$raw(');
                                addReplace(setupEnd, setupEnd, ')');
                            }
                            else {
                                addReplace(dotValue.beforeDot, dotValue.range.end, '');
                            }
                        }
                    }
                    if (isRefDeclaration) {
                        if (!declaration.leftIsIdentifier) {
                            addReplace(declaration.right.start, declaration.right.start, '$fromRefs(');
                            addReplace(declaration.right.end, declaration.right.end, ')');
                        }
                        else if (declaration.rightFn) {
                            const fnText = _scriptSetup.content.substring(declaration.rightFn.start, declaration.rightFn.end);
                            if (['ref', 'shallowRef'].includes(fnText)) {
                                addReplace(declaration.flag.start, declaration.flag.end, 'let');
                            }
                            if (['ref', 'computed', 'shallowRef'].includes(fnText)) {
                                addReplace(declaration.right.start, declaration.right.start, '$');
                            }
                        }
                        else {
                            addReplace(declaration.right.start, declaration.right.start, '$ref(');
                            addReplace(declaration.right.end, declaration.right.end, ')');
                        }
                    }
                }
                return edits;
                function addReplace(start, end, text) {
                    if (_scriptSetup.content.substring(start, end) === text)
                        return;
                    edits.push(vscode.TextEdit.replace({
                        start: document.positionAt(_scriptSetup.startTagEnd + start),
                        end: document.positionAt(_scriptSetup.startTagEnd + end),
                    }, text));
                }
            });
        }
    });
}
function unuseRefSugar(vueDocument, context, doCodeActions, doCodeActionResolve, doRename, doValidation) {
    var _a;
    return __awaiter(this, void 0, void 0, function* () {
        const descriptor = vueDocument.file.getDescriptor();
        if (!descriptor.scriptSetup)
            return;
        const scriptSetupAst = vueDocument.file.getScriptSetupAst();
        if (!scriptSetupAst)
            return;
        context.workDoneProgress.begin('Unuse Ref Sugar', 0, '', true);
        const edits = yield getUnRefSugarEdits(vueDocument, descriptor.scriptSetup, scriptSetupAst);
        if (context.token.isCancellationRequested)
            return;
        if (edits === null || edits === void 0 ? void 0 : edits.length) {
            yield context.applyEdit({ changes: { [vueDocument.uri]: edits } });
            yield shared.sleep(200);
            const errors = (_a = yield doValidation(vueDocument.uri)) !== null && _a !== void 0 ? _a : [];
            const importEdits = yield (0, vue_convert_scriptsetup_1.getAddMissingImportsEdits)(vueDocument, doCodeActions, doCodeActionResolve);
            const removeInvalidValueEdits = getRemoveInvalidDotValueEdits(vueDocument, errors);
            if (importEdits && removeInvalidValueEdits) {
                (0, rename_1.mergeWorkspaceEdits)(importEdits, removeInvalidValueEdits);
                yield context.applyEdit(importEdits);
            }
            else if (importEdits || removeInvalidValueEdits) {
                yield context.applyEdit((importEdits !== null && importEdits !== void 0 ? importEdits : removeInvalidValueEdits));
            }
        }
        context.workDoneProgress.done();
        function getRemoveInvalidDotValueEdits(_vueDocument, errors) {
            const document = _vueDocument.getDocument();
            const edits = [];
            for (const error of errors) {
                const errorText = document.getText(error.range);
                if (error.code === 2339 && errorText === 'value') {
                    edits.push(vscode.TextEdit.del({
                        start: {
                            line: error.range.start.line,
                            character: error.range.start.character - 1,
                        },
                        end: error.range.end,
                    }));
                }
            }
            if (!edits.length)
                return;
            const result = { documentChanges: [vscode.TextDocumentEdit.create(vscode.OptionalVersionedTextDocumentIdentifier.create(document.uri, document.version), edits)] };
            return result;
        }
        function getUnRefSugarEdits(_vueDocument, _scriptSetup, _scriptSetupAst) {
            return __awaiter(this, void 0, void 0, function* () {
                const ranges = _vueDocument.file.getSfcRefSugarRanges();
                const document = _vueDocument.getDocument();
                const edits = [];
                if (!ranges)
                    return;
                let varsNum = 0;
                let varsCur = 0;
                for (const callRange of ranges.refs) {
                    varsNum += callRange.leftBindings.length;
                }
                for (const callRange of ranges.refs) {
                    addReplace(callRange.flag.start, callRange.flag.end, 'const');
                    const fnName = _scriptSetup.content.substring(callRange.rightFn.start, callRange.rightFn.end);
                    if (fnName === '$fromRefs') {
                    }
                    else {
                        const newFnName = fnName.substring(1); // $ref -> ref
                        addReplace(callRange.rightFn.start, callRange.rightFn.end, newFnName);
                    }
                    for (const binding of callRange.leftBindings) {
                        if (context.token.isCancellationRequested)
                            return;
                        const varText = _scriptSetup.content.substring(binding.start, binding.end);
                        context.workDoneProgress.report(++varsCur / varsNum * 100, varText);
                        yield shared.sleep(0);
                        const bindingName = _scriptSetup.content.substring(binding.start, binding.end);
                        const renames = yield doRename(_vueDocument.uri, document.positionAt(_scriptSetup.startTagEnd + binding.end), bindingName + '.value');
                        if (renames === null || renames === void 0 ? void 0 : renames.changes) {
                            const edits_2 = renames.changes[_vueDocument.uri];
                            if (edits_2) {
                                for (const edit of edits_2) {
                                    const editRange = {
                                        start: document.offsetAt(edit.range.start),
                                        end: document.offsetAt(edit.range.end),
                                    };
                                    if (editRange.start >= (_scriptSetup.startTagEnd + binding.start) && editRange.end <= (_scriptSetup.startTagEnd + binding.end))
                                        continue;
                                    if (editRange.end < _scriptSetup.startTagEnd || editRange.start > _scriptSetup.startTagEnd + _scriptSetup.content.length)
                                        continue;
                                    if (inRawCall(editRange.start, editRange.end))
                                        continue;
                                    edits.push(edit);
                                }
                            }
                        }
                    }
                }
                for (const rawCall of ranges.raws) {
                    addReplace(rawCall.fullRange.start, rawCall.argsRange.start, '');
                    addReplace(rawCall.argsRange.end, rawCall.fullRange.end, '');
                }
                return edits;
                function inRawCall(start, end) {
                    if (ranges) {
                        for (const rawRange of ranges.raws) {
                            if (start >= (_scriptSetup.startTagEnd + rawRange.argsRange.start) && end <= (_scriptSetup.startTagEnd + rawRange.argsRange.end)) {
                                return true;
                            }
                        }
                    }
                    return false;
                }
                function addReplace(start, end, text) {
                    if (_scriptSetup.content.substring(start, end) === text)
                        return;
                    edits.push(vscode.TextEdit.replace({
                        start: document.positionAt(_scriptSetup.startTagEnd + start),
                        end: document.positionAt(_scriptSetup.startTagEnd + end),
                    }, text));
                }
            });
        }
    });
}
//# sourceMappingURL=vue-convert-refsugar.js.map