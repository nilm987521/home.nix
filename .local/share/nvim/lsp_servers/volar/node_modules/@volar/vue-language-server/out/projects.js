"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createProjects = void 0;
const shared = require("@volar/shared");
const path = require("upath");
const vscode = require("vscode-languageserver");
const project_1 = require("./project");
const utils_1 = require("./utils");
const rootTsConfigNames = ['tsconfig.json', 'jsconfig.json'];
function createProjects(runtimeEnv, rootPaths, ts, tsLocalized, options, documents, connection, lsConfigs, getInferredCompilerOptions) {
    let semanticTokensReq = 0;
    let documentUpdatedReq = 0;
    let lastOpenDoc;
    const updatedUris = new Set();
    const workspaces = new Map();
    for (const rootPath of rootPaths) {
        workspaces.set(rootPath, createWorkspace(runtimeEnv, rootPath, ts, tsLocalized, options, documents, connection, lsConfigs, getInferredCompilerOptions));
    }
    documents.onDidOpen((change) => __awaiter(this, void 0, void 0, function* () {
        lastOpenDoc = {
            uri: change.document.uri,
            time: Date.now(),
        };
    }));
    documents.onDidChangeContent((change) => __awaiter(this, void 0, void 0, function* () {
        yield waitForOnDidChangeWatchedFiles(change.document.uri);
        for (const workspace of workspaces.values()) {
            const projects = [...workspace.projects.values(), workspace.getInferredProjectDontCreate()].filter(shared.notEmpty);
            for (const project of projects) {
                (yield project).onDocumentUpdated(change.document);
            }
        }
        updateDiagnostics(change.document.uri);
    }));
    documents.onDidClose(change => {
        connection.sendDiagnostics({ uri: change.document.uri, diagnostics: [] });
    });
    connection.onDidChangeWatchedFiles((handler) => __awaiter(this, void 0, void 0, function* () {
        const tsConfigChanges = [];
        const scriptChanges = [];
        for (const workspace of workspaces.values()) {
            for (const change of handler.changes) {
                const fileName = shared.uriToFsPath(change.uri);
                if (rootTsConfigNames.includes(path.basename(fileName)) || workspace.projects.fsPathHas(fileName)) {
                    tsConfigChanges.push(change);
                }
                else {
                    scriptChanges.push(change);
                }
            }
            if (tsConfigChanges.length) {
                clearDiagnostics();
                for (const tsConfigChange of tsConfigChanges) {
                    const tsConfig = shared.uriToFsPath(tsConfigChange.uri);
                    if (workspace.projects.fsPathHas(tsConfig)) {
                        workspace.projects.fsPathDelete(tsConfig);
                        (() => __awaiter(this, void 0, void 0, function* () { var _a; return (_a = (yield workspace.projects.fsPathGet(tsConfig))) === null || _a === void 0 ? void 0 : _a.dispose(); }))();
                    }
                    if (tsConfigChange.type !== vscode.FileChangeType.Deleted) {
                        workspace.getProjectByCreate(tsConfig); // create new project
                    }
                }
            }
            if (scriptChanges.length) {
                const projects = [...workspace.projects.values(), workspace.getInferredProjectDontCreate()].filter(shared.notEmpty);
                for (const project of projects) {
                    yield (yield project).onWorkspaceFilesChanged(scriptChanges);
                }
            }
            onDriveFileUpdated(undefined);
        }
    }));
    updateDiagnostics(undefined);
    return {
        workspaces,
        getProject,
    };
    function onDriveFileUpdated(driveFileName) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            const req = ++semanticTokensReq;
            yield updateDiagnostics(driveFileName ? shared.fsPathToUri(driveFileName) : undefined);
            yield shared.sleep(100);
            if (req === semanticTokensReq) {
                if ((_a = options.languageFeatures) === null || _a === void 0 ? void 0 : _a.semanticTokens) {
                    connection.languages.semanticTokens.refresh();
                }
                if ((_b = options.languageFeatures) === null || _b === void 0 ? void 0 : _b.inlayHints) {
                    connection.languages.semanticTokens.refresh();
                }
            }
        });
    }
    function updateDiagnostics(docUri) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            if (!((_a = options.languageFeatures) === null || _a === void 0 ? void 0 : _a.diagnostics))
                return;
            if (docUri) {
                updatedUris.add(docUri);
            }
            const req = ++documentUpdatedReq;
            yield shared.sleep(100);
            if (req !== documentUpdatedReq)
                return;
            const changeDocs = [...updatedUris].map(uri => (0, utils_1.getDocumentSafely)(documents, uri)).filter(shared.notEmpty);
            const otherDocs = documents.all().filter(doc => !updatedUris.has(doc.uri));
            for (const changeDoc of changeDocs) {
                if (req !== documentUpdatedReq)
                    return;
                let _isCancel = false;
                const isDocCancel = getCancelChecker(changeDoc.uri, changeDoc.version);
                const isCancel = () => __awaiter(this, void 0, void 0, function* () {
                    const result = req !== documentUpdatedReq || (yield isDocCancel());
                    _isCancel = result;
                    return result;
                });
                yield sendDocumentDiagnostics(changeDoc.uri, isCancel);
                if (!_isCancel) {
                    updatedUris.delete(changeDoc.uri);
                }
            }
            for (const doc of otherDocs) {
                if (req !== documentUpdatedReq)
                    return;
                const changeDoc = docUri ? (0, utils_1.getDocumentSafely)(documents, docUri) : undefined;
                const isDocCancel = changeDoc ? getCancelChecker(changeDoc.uri, changeDoc.version) : () => __awaiter(this, void 0, void 0, function* () {
                    yield shared.sleep(0);
                    return false;
                });
                const isCancel = () => __awaiter(this, void 0, void 0, function* () { return req !== documentUpdatedReq || (yield isDocCancel()); });
                yield sendDocumentDiagnostics(doc.uri, isCancel);
            }
            function getCancelChecker(uri, version) {
                let _isCancel = false;
                let lastResultAt = Date.now();
                return () => __awaiter(this, void 0, void 0, function* () {
                    var _a;
                    if (_isCancel) {
                        return true;
                    }
                    if (typeof ((_a = options.languageFeatures) === null || _a === void 0 ? void 0 : _a.diagnostics) === 'object'
                        && options.languageFeatures.diagnostics.getDocumentVersionRequest
                        && Date.now() - lastResultAt >= 1 // 1ms
                    ) {
                        const clientDocVersion = yield connection.sendRequest(shared.GetDocumentVersionRequest.type, { uri });
                        if (clientDocVersion !== null && clientDocVersion !== undefined && version !== clientDocVersion) {
                            _isCancel = true;
                        }
                        lastResultAt = Date.now();
                    }
                    return _isCancel;
                });
            }
            function sendDocumentDiagnostics(uri, isCancel) {
                var _a;
                return __awaiter(this, void 0, void 0, function* () {
                    const project = (_a = (yield getProject(uri))) === null || _a === void 0 ? void 0 : _a.project;
                    if (!project)
                        return;
                    const languageService = project.getLanguageService();
                    const errors = yield languageService.doValidation(uri, (result) => __awaiter(this, void 0, void 0, function* () {
                        connection.sendDiagnostics({ uri: uri, diagnostics: result });
                    }), isCancel);
                    if (errors) {
                        connection.sendDiagnostics({ uri: uri, diagnostics: errors });
                    }
                });
            }
        });
    }
    function getProject(uri) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            yield waitForOnDidChangeWatchedFiles(uri);
            const fileName = shared.uriToFsPath(uri);
            const rootPaths = [...workspaces.keys()]
                .filter(rootPath => shared.isFileInDir(fileName, rootPath))
                .sort(sortPaths);
            for (const rootPath of rootPaths) {
                const workspace = workspaces.get(rootPath);
                const project = yield (workspace === null || workspace === void 0 ? void 0 : workspace.getProjectAndTsConfig(uri));
                if (project) {
                    return project;
                }
            }
            if (rootPaths.length) {
                return {
                    tsconfig: undefined,
                    project: yield ((_a = workspaces.get(rootPaths[0])) === null || _a === void 0 ? void 0 : _a.getInferredProject()),
                };
            }
        });
    }
    function waitForOnDidChangeWatchedFiles(uri) {
        return __awaiter(this, void 0, void 0, function* () {
            if ((lastOpenDoc === null || lastOpenDoc === void 0 ? void 0 : lastOpenDoc.uri) === uri) {
                const dt = lastOpenDoc.time + 2000 - Date.now();
                if (dt > 0) {
                    yield shared.sleep(dt);
                }
            }
        });
    }
    function clearDiagnostics() {
        for (const doc of documents.all()) {
            connection.sendDiagnostics({ uri: doc.uri, diagnostics: [] });
        }
    }
}
exports.createProjects = createProjects;
function createWorkspace(runtimeEnv, rootPath, ts, tsLocalized, options, documents, connection, lsConfigs, getInferredCompilerOptions) {
    const rootTsConfigs = ts.sys.readDirectory(rootPath, rootTsConfigNames, undefined, ['**/*']);
    const projects = shared.createPathMap();
    let inferredProject;
    return {
        projects,
        getProject,
        getProjectAndTsConfig,
        getProjectByCreate,
        getInferredProject,
        getInferredProjectDontCreate: () => inferredProject,
    };
    function getProject(uri) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            return (_a = (yield getProjectAndTsConfig(uri))) === null || _a === void 0 ? void 0 : _a.project;
        });
    }
    function getProjectAndTsConfig(uri) {
        return __awaiter(this, void 0, void 0, function* () {
            const tsconfig = yield findMatchConfigs(uri);
            if (tsconfig) {
                const project = yield getProjectByCreate(tsconfig);
                return {
                    tsconfig: tsconfig,
                    project,
                };
            }
        });
    }
    function getInferredProject() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!inferredProject) {
                inferredProject = (0, project_1.createProject)(runtimeEnv, ts, options, rootPath, yield getInferredCompilerOptions(), tsLocalized, documents, connection, lsConfigs);
            }
            return inferredProject;
        });
    }
    function findMatchConfigs(uri) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const fileName = shared.uriToFsPath(uri);
            prepareClosestootParsedCommandLine();
            return (_a = yield findDirectIncludeTsconfig()) !== null && _a !== void 0 ? _a : yield findIndirectReferenceTsconfig();
            function prepareClosestootParsedCommandLine() {
                let matches = [];
                for (const rootTsConfig of rootTsConfigs) {
                    if (shared.isFileInDir(shared.uriToFsPath(uri), path.dirname(rootTsConfig))) {
                        matches.push(rootTsConfig);
                    }
                }
                matches = matches.sort(sortPaths);
                if (matches.length) {
                    getParsedCommandLine(matches[0]);
                }
            }
            function findDirectIncludeTsconfig() {
                return findTsconfig((tsconfig) => __awaiter(this, void 0, void 0, function* () {
                    const parsedCommandLine = yield getParsedCommandLine(tsconfig);
                    const fileNames = new Set(parsedCommandLine.fileNames);
                    return fileNames.has(fileName);
                }));
            }
            function findIndirectReferenceTsconfig() {
                return findTsconfig((tsconfig) => __awaiter(this, void 0, void 0, function* () {
                    const project = yield projects.fsPathGet(tsconfig);
                    const ls = yield (project === null || project === void 0 ? void 0 : project.getLanguageServiceDontCreate());
                    const validDoc = ls === null || ls === void 0 ? void 0 : ls.__internal__.context.getTsLs().__internal__.getValidTextDocument(uri);
                    return !!validDoc;
                }));
            }
            function findTsconfig(match) {
                return __awaiter(this, void 0, void 0, function* () {
                    const checked = new Set();
                    for (const rootTsConfig of rootTsConfigs.sort(sortPaths)) {
                        const project = yield projects.fsPathGet(rootTsConfig);
                        if (project) {
                            const chains = yield getReferencesChains(project.getParsedCommandLine(), rootTsConfig, []);
                            for (const chain of chains) {
                                for (let i = chain.length - 1; i >= 0; i--) {
                                    const tsconfig = chain[i];
                                    if (checked.has(tsconfig))
                                        continue;
                                    checked.add(tsconfig);
                                    if (yield match(tsconfig)) {
                                        return tsconfig;
                                    }
                                }
                            }
                        }
                    }
                });
            }
            function getReferencesChains(parsedCommandLine, tsConfig, before) {
                var _a;
                return __awaiter(this, void 0, void 0, function* () {
                    if ((_a = parsedCommandLine.projectReferences) === null || _a === void 0 ? void 0 : _a.length) {
                        const newChains = [];
                        for (const projectReference of parsedCommandLine.projectReferences) {
                            let tsConfigPath = projectReference.path;
                            // fix https://github.com/johnsoncodehk/volar/issues/712
                            if (!ts.sys.fileExists(tsConfigPath) && ts.sys.directoryExists(tsConfigPath)) {
                                const newTsConfigPath = path.join(tsConfigPath, 'tsconfig.json');
                                const newJsConfigPath = path.join(tsConfigPath, 'jsconfig.json');
                                if (ts.sys.fileExists(newTsConfigPath)) {
                                    tsConfigPath = newTsConfigPath;
                                }
                                else if (ts.sys.fileExists(newJsConfigPath)) {
                                    tsConfigPath = newJsConfigPath;
                                }
                            }
                            const beforeIndex = before.indexOf(tsConfigPath); // cycle
                            if (beforeIndex >= 0) {
                                newChains.push(before.slice(0, Math.max(beforeIndex, 1)));
                            }
                            else {
                                const referenceParsedCommandLine = yield getParsedCommandLine(tsConfigPath);
                                for (const chain of yield getReferencesChains(referenceParsedCommandLine, tsConfigPath, [...before, tsConfig])) {
                                    newChains.push(chain);
                                }
                            }
                        }
                        return newChains;
                    }
                    else {
                        return [[...before, tsConfig]];
                    }
                });
            }
            function getParsedCommandLine(tsConfig) {
                return __awaiter(this, void 0, void 0, function* () {
                    const project = yield getProjectByCreate(tsConfig);
                    return project.getParsedCommandLine();
                });
            }
        });
    }
    function getProjectByCreate(tsConfig) {
        let project = projects.fsPathGet(tsConfig);
        if (!project) {
            project = (0, project_1.createProject)(runtimeEnv, ts, options, path.dirname(tsConfig), tsConfig, tsLocalized, documents, connection, lsConfigs);
            projects.fsPathSet(tsConfig, project);
        }
        return project;
    }
}
function sortPaths(a, b) {
    const aLength = a.split('/').length;
    const bLength = b.split('/').length;
    if (aLength === bLength) {
        const aWeight = path.basename(a) === 'tsconfig.json' ? 1 : 0;
        const bWeight = path.basename(b) === 'tsconfig.json' ? 1 : 0;
        return bWeight - aWeight;
    }
    return bLength - aLength;
}
//# sourceMappingURL=projects.js.map