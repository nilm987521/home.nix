"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.semanticTokenTypes = void 0;
const shared = require("@volar/shared");
const scriptRanges_1 = require("@volar/vue-code-gen/out/parsers/scriptRanges");
const vue_typescript_1 = require("@volar/vue-typescript");
const reactivity_1 = require("@vue/reactivity");
const shared_1 = require("@vue/shared");
const vue_code_gen_1 = require("@volar/vue-code-gen");
const path = require("upath");
const html = require("vscode-html-languageservice");
const vscode = require("vscode-languageserver-protocol");
const vue_language_service_types_1 = require("@volar/vue-language-service-types");
exports.semanticTokenTypes = [
    'componentTag',
];
// https://v3.vuejs.org/api/directives.html#v-on
const eventModifiers = {
    stop: 'call event.stopPropagation().',
    prevent: 'call event.preventDefault().',
    capture: 'add event listener in capture mode.',
    self: 'only trigger handler if event was dispatched from this element.',
    // {keyAlias}: 'only trigger handler on certain keys.',
    once: 'trigger handler at most once.',
    left: 'only trigger handler for left button mouse events.',
    right: 'only trigger handler for right button mouse events.',
    middle: 'only trigger handler for middle button mouse events.',
    passive: 'attaches a DOM event with { passive: true }.',
};
const vueGlobalDirectiveProvider = html.newHTMLDataProvider('vueGlobalDirective', {
    version: 1.1,
    tags: [],
    globalAttributes: [
        { name: 'v-if' },
        { name: 'v-else-if' },
        { name: 'v-else', valueSet: 'v' },
        { name: 'v-for' },
    ],
});
function useVueTemplateLanguagePlugin(options) {
    var _a, _b;
    const componentCompletionDataCache = new WeakMap();
    const autoImportPositions = new WeakSet();
    const tokenTypes = new Map(options.getSemanticTokenLegend().tokenTypes.map((t, i) => [t, i]));
    const runtimeMode = options.tsRuntime.vueLsHost.getVueCompilationSettings().experimentalRuntimeMode;
    return Object.assign(Object.assign({}, options.templateLanguagePlugin), { complete: {
            triggerCharacters: [
                ...(_b = (_a = options.templateLanguagePlugin.complete) === null || _a === void 0 ? void 0 : _a.triggerCharacters) !== null && _b !== void 0 ? _b : [],
                '@', // vue event shorthand
            ],
            on(document, position, context) {
                var _a, _b;
                return __awaiter(this, void 0, void 0, function* () {
                    if (!options.isSupportedDocument(document))
                        return;
                    const vueDocument = options.vueDocuments.fromEmbeddedDocument(document);
                    let tsItems;
                    if (vueDocument) {
                        tsItems = yield provideHtmlData(vueDocument);
                    }
                    const htmlComplete = yield ((_b = (_a = options.templateLanguagePlugin.complete) === null || _a === void 0 ? void 0 : _a.on) === null || _b === void 0 ? void 0 : _b.call(_a, document, position, context));
                    if (!htmlComplete)
                        return;
                    if (vueDocument && tsItems) {
                        afterHtmlCompletion(htmlComplete, vueDocument, tsItems);
                    }
                    return htmlComplete;
                });
            },
            resolve(item) {
                return __awaiter(this, void 0, void 0, function* () {
                    const data = item.data;
                    if ((data === null || data === void 0 ? void 0 : data.mode) === 'html') {
                        return yield resolveHtmlItem(item, data);
                    }
                    else if ((data === null || data === void 0 ? void 0 : data.mode) === 'autoImport') {
                        return yield resolveAutoImportItem(item, data);
                    }
                    return item;
                });
            },
        }, doValidation(document, options_2) {
            var _a, _b;
            return __awaiter(this, void 0, void 0, function* () {
                if (!options.isSupportedDocument(document))
                    return;
                const originalResult = yield ((_b = (_a = options.templateLanguagePlugin).doValidation) === null || _b === void 0 ? void 0 : _b.call(_a, document, options_2));
                const vueDocument = options.vueDocuments.fromEmbeddedDocument(document);
                if (vueDocument) {
                    const templateErrors = [];
                    const sfcVueTemplateCompiled = vueDocument.file.getSfcVueTemplateCompiled();
                    const sfcTemplateLanguageCompiled = vueDocument.file.getSfcTemplateLanguageCompiled();
                    const sfcTemplate = vueDocument.file.getSfcTemplateDocument();
                    if (sfcVueTemplateCompiled && sfcTemplateLanguageCompiled && sfcTemplate) {
                        for (const error of sfcVueTemplateCompiled.errors) {
                            onCompilerError(error, vscode.DiagnosticSeverity.Error);
                        }
                        for (const warning of sfcVueTemplateCompiled.warnings) {
                            onCompilerError(warning, vscode.DiagnosticSeverity.Warning);
                        }
                        function onCompilerError(error, severity) {
                            var _a, _b, _c, _d;
                            const templateHtmlRange = {
                                start: (_b = (_a = error.loc) === null || _a === void 0 ? void 0 : _a.start.offset) !== null && _b !== void 0 ? _b : 0,
                                end: (_d = (_c = error.loc) === null || _c === void 0 ? void 0 : _c.end.offset) !== null && _d !== void 0 ? _d : 0,
                            };
                            let sourceRange = sfcTemplateLanguageCompiled.htmlToTemplate(templateHtmlRange.start, templateHtmlRange.end);
                            let errorMessage = error.message;
                            if (!sourceRange) {
                                const htmlText = sfcTemplateLanguageCompiled.htmlText.substring(templateHtmlRange.start, templateHtmlRange.end);
                                errorMessage += '\n```html\n' + htmlText.trim() + '\n```';
                                sourceRange = { start: 0, end: 0 };
                            }
                            templateErrors.push({
                                range: {
                                    start: document.positionAt(sourceRange.start),
                                    end: document.positionAt(sourceRange.end),
                                },
                                severity,
                                code: error.code,
                                source: 'vue',
                                message: errorMessage,
                            });
                        }
                    }
                    return [
                        ...originalResult !== null && originalResult !== void 0 ? originalResult : [],
                        ...templateErrors,
                    ];
                }
            });
        },
        findDocumentSemanticTokens(document, range) {
            var _a, _b, _c, _d;
            return __awaiter(this, void 0, void 0, function* () {
                if (!options.isSupportedDocument(document))
                    return;
                const result = (_c = yield ((_b = (_a = options.templateLanguagePlugin).findDocumentSemanticTokens) === null || _b === void 0 ? void 0 : _b.call(_a, document, range))) !== null && _c !== void 0 ? _c : [];
                const vueDocument = options.vueDocuments.fromEmbeddedDocument(document);
                const scanner = options.getScanner(document);
                if (vueDocument && scanner) {
                    const templateScriptData = vueDocument.file.getTemplateData();
                    const components = new Set([
                        ...templateScriptData.components,
                        ...templateScriptData.components.map(shared_1.hyphenate).filter(name => !(0, vue_code_gen_1.isIntrinsicElement)(runtimeMode, name)),
                    ]);
                    const offsetRange = range ? {
                        start: document.offsetAt(range.start),
                        end: document.offsetAt(range.end),
                    } : {
                        start: 0,
                        end: document.getText().length,
                    };
                    let token = scanner.scan();
                    while (token !== html.TokenType.EOS) {
                        const tokenOffset = scanner.getTokenOffset();
                        // TODO: fix source map perf and break in while condition
                        if (tokenOffset > offsetRange.end)
                            break;
                        if (tokenOffset >= offsetRange.start && (token === html.TokenType.StartTag || token === html.TokenType.EndTag)) {
                            const tokenText = scanner.getTokenText();
                            if (components.has(tokenText) || tokenText.indexOf('.') >= 0) {
                                const tokenLength = scanner.getTokenLength();
                                const tokenPosition = document.positionAt(tokenOffset);
                                if (components.has(tokenText)) {
                                    result.push([tokenPosition.line, tokenPosition.character, tokenLength, (_d = tokenTypes.get('componentTag')) !== null && _d !== void 0 ? _d : -1, 0]);
                                }
                            }
                        }
                        token = scanner.scan();
                    }
                }
                return result;
            });
        },
        resolveEmbeddedRange(range) {
            if (autoImportPositions.has(range.start) && autoImportPositions.has(range.end))
                return range;
        } });
    // not supported for now
    function resolveHtmlItem(item, data) {
        return __awaiter(this, void 0, void 0, function* () {
            // let tsItem = data.tsItem;
            // if (!tsItem)
            //     return item;
            // if (!host.templateTsLs)
            //     return item;
            // tsItem = await host.templateTsLs.doCompletionResolve(tsItem);
            // item.tags = [...item.tags ?? [], ...tsItem.tags ?? []];
            // const details: string[] = [];
            // const documentations: string[] = [];
            // if (item.detail) details.push(item.detail);
            // if (tsItem.detail) details.push(tsItem.detail);
            // if (details.length) {
            //     item.detail = details.join('\n\n');
            // }
            // if (item.documentation) documentations.push(typeof item.documentation === 'string' ? item.documentation : item.documentation.value);
            // if (tsItem.documentation) documentations.push(typeof tsItem.documentation === 'string' ? tsItem.documentation : tsItem.documentation.value);
            // if (documentations.length) {
            //     item.documentation = {
            //         kind: vscode.MarkupKind.Markdown,
            //         value: documentations.join('\n\n'),
            //     };
            // }
            return item;
        });
    }
    function resolveAutoImportItem(item, data) {
        return __awaiter(this, void 0, void 0, function* () {
            const _vueDocument = options.vueDocuments.get(data.vueDocumentUri);
            if (!_vueDocument)
                return item;
            const vueDocument = _vueDocument;
            const importFile = shared.uriToFsPath(data.importUri);
            const rPath = path.relative(options.vueLsHost.getCurrentDirectory(), importFile);
            const descriptor = vueDocument.file.getDescriptor();
            const scriptAst = vueDocument.file.getScriptAst();
            const scriptSetupAst = vueDocument.file.getScriptSetupAst();
            let importPath = path.relative(path.dirname(data.vueDocumentUri), data.importUri);
            if (!importPath.startsWith('.')) {
                importPath = './' + importPath;
            }
            if (!descriptor.scriptSetup && !descriptor.script) {
                item.detail = `Auto import from '${importPath}'\n\n${rPath}`;
                item.documentation = {
                    kind: vscode.MarkupKind.Markdown,
                    value: '[Error] `<script>` / `<script setup>` block not found.',
                };
                return item;
            }
            item.labelDetails = { description: rPath };
            const scriptImport = scriptAst ? getLastImportNode(scriptAst) : undefined;
            const scriptSetupImport = scriptSetupAst ? getLastImportNode(scriptSetupAst) : undefined;
            const componentName = (0, shared_1.capitalize)((0, shared_1.camelize)(item.label.replace(/\./g, '-')));
            const textDoc = vueDocument.getDocument();
            let insertText = '';
            const planAResult = yield planAInsertText();
            if (planAResult) {
                insertText = planAResult.insertText;
                item.detail = planAResult.description + '\n\n' + rPath;
            }
            else {
                insertText = planBInsertText();
                item.detail = `Auto import from '${importPath}'\n\n${rPath}`;
            }
            if (descriptor.scriptSetup) {
                const editPosition = textDoc.positionAt(descriptor.scriptSetup.startTagEnd + (scriptSetupImport ? scriptSetupImport.end : 0));
                autoImportPositions.add(editPosition);
                item.additionalTextEdits = [
                    vscode.TextEdit.insert(editPosition, '\n' + insertText),
                ];
            }
            else if (descriptor.script && scriptAst) {
                const editPosition = textDoc.positionAt(descriptor.script.startTagEnd + (scriptImport ? scriptImport.end : 0));
                autoImportPositions.add(editPosition);
                item.additionalTextEdits = [
                    vscode.TextEdit.insert(editPosition, '\n' + insertText),
                ];
                const scriptRanges = (0, scriptRanges_1.parseScriptRanges)(options.ts, scriptAst, !!descriptor.scriptSetup, true, true);
                const exportDefault = scriptRanges.exportDefault;
                if (exportDefault) {
                    // https://github.com/microsoft/TypeScript/issues/36174
                    const printer = options.ts.createPrinter();
                    if (exportDefault.componentsOption && exportDefault.componentsOptionNode) {
                        const newNode = Object.assign(Object.assign({}, exportDefault.componentsOptionNode), { properties: [
                                ...exportDefault.componentsOptionNode.properties,
                                options.ts.factory.createShorthandPropertyAssignment(componentName),
                            ] });
                        const printText = printer.printNode(options.ts.EmitHint.Expression, newNode, scriptAst);
                        const editRange = vscode.Range.create(textDoc.positionAt(descriptor.script.startTagEnd + exportDefault.componentsOption.start), textDoc.positionAt(descriptor.script.startTagEnd + exportDefault.componentsOption.end));
                        autoImportPositions.add(editRange.start);
                        autoImportPositions.add(editRange.end);
                        item.additionalTextEdits.push(vscode.TextEdit.replace(editRange, unescape(printText.replace(/\\u/g, '%u'))));
                    }
                    else if (exportDefault.args && exportDefault.argsNode) {
                        const newNode = Object.assign(Object.assign({}, exportDefault.argsNode), { properties: [
                                ...exportDefault.argsNode.properties,
                                options.ts.factory.createShorthandPropertyAssignment(`components: { ${componentName} }`),
                            ] });
                        const printText = printer.printNode(options.ts.EmitHint.Expression, newNode, scriptAst);
                        const editRange = vscode.Range.create(textDoc.positionAt(descriptor.script.startTagEnd + exportDefault.args.start), textDoc.positionAt(descriptor.script.startTagEnd + exportDefault.args.end));
                        autoImportPositions.add(editRange.start);
                        autoImportPositions.add(editRange.end);
                        item.additionalTextEdits.push(vscode.TextEdit.replace(editRange, unescape(printText.replace(/\\u/g, '%u'))));
                    }
                }
            }
            return item;
            function planAInsertText() {
                var _a, _b, _c, _d, _e, _f;
                return __awaiter(this, void 0, void 0, function* () {
                    const embeddedScriptFile = vueDocument.file.getScriptTsFile();
                    const embeddedScriptDocument = vueDocument.embeddedDocumentsMap.get(embeddedScriptFile);
                    const tsImportName = (0, shared_1.camelize)(path.basename(importFile).replace(/\./g, '-'));
                    const [formatOptions, preferences] = yield Promise.all([
                        (_c = (_b = (_a = options.tsSettings).getFormatOptions) === null || _b === void 0 ? void 0 : _b.call(_a, embeddedScriptDocument)) !== null && _c !== void 0 ? _c : {},
                        (_f = (_e = (_d = options.tsSettings).getPreferences) === null || _e === void 0 ? void 0 : _e.call(_d, embeddedScriptDocument)) !== null && _f !== void 0 ? _f : {},
                    ]);
                    const tsDetail = options.tsLs.__internal__.raw.getCompletionEntryDetails(shared.uriToFsPath(embeddedScriptDocument.uri), 0, tsImportName, formatOptions, importFile, preferences, undefined);
                    if (tsDetail === null || tsDetail === void 0 ? void 0 : tsDetail.codeActions) {
                        for (const action of tsDetail.codeActions) {
                            for (const change of action.changes) {
                                for (const textChange of change.textChanges) {
                                    if (textChange.newText.indexOf(`import ${tsImportName} `) >= 0) {
                                        return {
                                            insertText: textChange.newText.replace(`import ${tsImportName} `, `import ${componentName} `).trim(),
                                            description: action.description,
                                        };
                                    }
                                }
                            }
                        }
                    }
                });
            }
            function planBInsertText() {
                const anyImport = scriptSetupImport !== null && scriptSetupImport !== void 0 ? scriptSetupImport : scriptImport;
                let withSemicolon = true;
                let quote = '"';
                if (anyImport) {
                    withSemicolon = anyImport.text.endsWith(';');
                    quote = anyImport.text.includes("'") ? "'" : '"';
                }
                return `import ${componentName} from ${quote}${importPath}${quote}${withSemicolon ? ';' : ''}`;
            }
        });
    }
    function provideHtmlData(vueDocument) {
        var _a, _b, _c, _d;
        return __awaiter(this, void 0, void 0, function* () {
            const nameCases = (_b = yield ((_a = options.getNameCases) === null || _a === void 0 ? void 0 : _a.call(options, vueDocument.uri))) !== null && _b !== void 0 ? _b : {
                tag: 'both',
                attr: 'kebabCase',
            };
            const componentCompletion = getComponentCompletionData(vueDocument);
            const tags = [];
            const tsItems = new Map();
            const globalAttributes = [];
            for (const [_componentName, { item, bind, on }] of componentCompletion) {
                const componentNames = nameCases.tag === 'kebabCase' ? new Set([(0, shared_1.hyphenate)(_componentName)])
                    : nameCases.tag === 'pascalCase' ? new Set([_componentName])
                        : new Set([(0, shared_1.hyphenate)(_componentName), _componentName]);
                for (const componentName of componentNames) {
                    const attributes = componentName === '*' ? globalAttributes : [];
                    for (const prop of bind) {
                        const name = nameCases.attr === 'camelCase' ? prop.name : (0, shared_1.hyphenate)(prop.name);
                        if ((0, shared_1.hyphenate)(name).startsWith('on-')) {
                            const propNameBase = name.startsWith('on-')
                                ? name.slice('on-'.length)
                                : (name['on'.length].toLowerCase() + name.slice('onX'.length));
                            const propKey = createInternalItemId('componentEvent', [componentName, propNameBase]);
                            attributes.push({
                                name: 'v-on:' + propNameBase,
                                description: propKey,
                            }, {
                                name: '@' + propNameBase,
                                description: propKey,
                            });
                            tsItems.set(propKey, prop);
                        }
                        else {
                            const propName = name;
                            const propKey = createInternalItemId('componentProp', [componentName, propName]);
                            attributes.push({
                                name: propName,
                                description: propKey,
                            }, {
                                name: ':' + propName,
                                description: propKey,
                            }, {
                                name: 'v-bind:' + propName,
                                description: propKey,
                            });
                            tsItems.set(propKey, prop);
                        }
                    }
                    for (const event of on) {
                        const name = nameCases.attr === 'camelCase' ? event.name : (0, shared_1.hyphenate)(event.name);
                        const propKey = createInternalItemId('componentEvent', [componentName, name]);
                        attributes.push({
                            name: 'v-on:' + name,
                            description: propKey,
                        });
                        attributes.push({
                            name: '@' + name,
                            description: propKey,
                        });
                        tsItems.set(propKey, event);
                    }
                    const componentKey = createInternalItemId('component', [componentName]);
                    if (componentName !== '*') {
                        tags.push({
                            name: componentName,
                            description: componentKey,
                            attributes,
                        });
                    }
                    if (item) {
                        tsItems.set(componentKey, item);
                    }
                }
            }
            const descriptor = vueDocument.file.getDescriptor();
            const enabledComponentAutoImport = (_d = yield ((_c = (0, vue_language_service_types_1.useConfigurationHost)()) === null || _c === void 0 ? void 0 : _c.getConfiguration('volar.completion.autoImportComponent'))) !== null && _d !== void 0 ? _d : true;
            if (enabledComponentAutoImport && (descriptor.script || descriptor.scriptSetup)) {
                for (const vueDocument of options.vueDocuments.getAll()) {
                    let baseName = path.basename(vueDocument.uri, '.vue');
                    if (baseName.toLowerCase() === 'index') {
                        baseName = path.basename(path.dirname(vueDocument.uri));
                    }
                    baseName = baseName.replace(/\./g, '-');
                    const componentName_1 = (0, shared_1.hyphenate)(baseName);
                    const componentName_2 = (0, shared_1.capitalize)((0, shared_1.camelize)(baseName));
                    let i = '';
                    if (componentCompletion.has(componentName_1) || componentCompletion.has(componentName_2)) {
                        i = 1;
                        while (componentCompletion.has(componentName_1 + i) || componentCompletion.has(componentName_2 + i)) {
                            i++;
                        }
                    }
                    tags.push({
                        name: (nameCases.tag === 'kebabCase' ? componentName_1 : componentName_2) + i,
                        description: createInternalItemId('importFile', [vueDocument.uri]),
                        attributes: [],
                    });
                }
            }
            const dataProvider = html.newHTMLDataProvider('vue-html', {
                version: 1.1,
                tags,
                globalAttributes,
            });
            options.templateLanguagePlugin.htmlLs.setDataProviders(true, [
                ...options.templateLanguagePlugin.getHtmlDataProviders(),
                vueGlobalDirectiveProvider,
                dataProvider,
            ]);
            return tsItems;
        });
    }
    function afterHtmlCompletion(completionList, vueDocument, tsItems) {
        var _a, _b, _c, _d, _e, _f, _g;
        const replacement = getReplacement(completionList, vueDocument.getDocument());
        if (replacement) {
            const isEvent = replacement.text.startsWith('@') || replacement.text.startsWith('v-on:');
            const hasModifier = replacement.text.includes('.');
            if (isEvent && hasModifier) {
                const modifiers = replacement.text.split('.').slice(1);
                const textWithoutModifier = path.trimExt(replacement.text, [], 999);
                for (const modifier in eventModifiers) {
                    if (modifiers.includes(modifier))
                        continue;
                    const modifierDes = eventModifiers[modifier];
                    const newItem = {
                        label: modifier,
                        filterText: textWithoutModifier + '.' + modifier,
                        documentation: modifierDes,
                        textEdit: {
                            range: replacement.textEdit.range,
                            newText: textWithoutModifier + '.' + modifier,
                        },
                        kind: vscode.CompletionItemKind.EnumMember,
                    };
                    completionList.items.push(newItem);
                }
            }
        }
        for (const item of completionList.items) {
            const itemIdKey = typeof item.documentation === 'string' ? item.documentation : (_a = item.documentation) === null || _a === void 0 ? void 0 : _a.value;
            const itemId = itemIdKey ? readInternalItemId(itemIdKey) : undefined;
            if (itemId) {
                item.documentation = undefined;
            }
            if ((itemId === null || itemId === void 0 ? void 0 : itemId.type) === 'importFile') {
                const [fileUri] = itemId.args;
                const filePath = shared.uriToFsPath(fileUri);
                const rPath = path.relative(options.vueLsHost.getCurrentDirectory(), filePath);
                const data = {
                    mode: 'autoImport',
                    vueDocumentUri: vueDocument.uri,
                    importUri: fileUri,
                };
                item.labelDetails = { description: rPath };
                item.filterText = item.label + ' ' + rPath;
                item.detail = rPath;
                item.kind = vscode.CompletionItemKind.File;
                item.sortText = '\u0003' + ((_b = item.sortText) !== null && _b !== void 0 ? _b : item.label);
                item.data = data;
            }
            else if (itemIdKey && itemId) {
                const tsItem = itemIdKey ? tsItems.get(itemIdKey) : undefined;
                if (itemId.type === 'componentProp' || itemId.type === 'componentEvent') {
                    const [componentName] = itemId.args;
                    if (componentName !== '*') {
                        item.sortText = '\u0000' + ((_c = item.sortText) !== null && _c !== void 0 ? _c : item.label);
                    }
                    if (tsItem) {
                        if (itemId.type === 'componentProp') {
                            item.kind = vscode.CompletionItemKind.Property;
                        }
                        else {
                            item.kind = vscode.CompletionItemKind.Event;
                        }
                    }
                }
                else if (item.label === 'v-if'
                    || item.label === 'v-else-if'
                    || item.label === 'v-else'
                    || item.label === 'v-for') {
                    item.kind = vscode.CompletionItemKind.Method;
                    item.sortText = '\u0003' + ((_d = item.sortText) !== null && _d !== void 0 ? _d : item.label);
                }
                else if (item.label.startsWith('v-')) {
                    item.kind = vscode.CompletionItemKind.Function;
                    item.sortText = '\u0002' + ((_e = item.sortText) !== null && _e !== void 0 ? _e : item.label);
                }
                else {
                    item.sortText = '\u0001' + ((_f = item.sortText) !== null && _f !== void 0 ? _f : item.label);
                }
                const data = {
                    mode: 'html',
                    tsItem: tsItem,
                };
                item.data = data;
            }
        }
        {
            const temp = new Map();
            for (const item of completionList.items) {
                const data = item.data;
                if ((data === null || data === void 0 ? void 0 : data.mode) === 'autoImport' && data.importUri === vueDocument.uri) { // don't import itself
                    continue;
                }
                if (!((_g = temp.get(item.label)) === null || _g === void 0 ? void 0 : _g.documentation)) { // filter HTMLAttributes
                    temp.set(item.label, item);
                }
            }
            completionList.items = [...temp.values()];
        }
        options.templateLanguagePlugin.htmlLs.setDataProviders(true, options.templateLanguagePlugin.getHtmlDataProviders());
    }
    function getLastImportNode(ast) {
        let importNode;
        ast.forEachChild(node => {
            if (options.ts.isImportDeclaration(node)) {
                importNode = node;
            }
        });
        return importNode ? {
            text: importNode.getFullText(ast).trim(),
            end: importNode.getEnd(),
        } : undefined;
    }
    function getComponentCompletionData(sourceFile) {
        var _a, _b, _c, _d, _e, _f;
        const templateData = sourceFile.file.getTemplateData();
        let cache = componentCompletionDataCache.get(templateData);
        if (!cache) {
            const { sfcTemplateScript } = sourceFile.file.refs;
            cache = new Map();
            (0, reactivity_1.pauseTracking)();
            const file = sfcTemplateScript.file.value;
            const templateTagNames = sfcTemplateScript.templateCodeGens.value ? Object.keys(sfcTemplateScript.templateCodeGens.value.tagNames) : [];
            (0, reactivity_1.resetTracking)();
            if (file) {
                const tags_1 = templateData.componentItems.map(item => {
                    return { item, name: item.name };
                });
                const tags_2 = templateTagNames
                    .filter(tag => tag.indexOf('.') >= 0)
                    .map(tag => ({ name: tag, item: undefined }));
                for (const tag of [...tags_1, ...tags_2]) {
                    if (cache.has(tag.name))
                        continue;
                    let bind = [];
                    let on = [];
                    {
                        const searchText = vue_typescript_1.SearchTexts.PropsCompletion(tag.name);
                        let offset = file.content.indexOf(searchText);
                        if (offset >= 0) {
                            offset += searchText.length;
                            try {
                                bind = (_b = (_a = options.tsRuntime.getTsLs().getCompletionsAtPosition(file.fileName, offset, undefined)) === null || _a === void 0 ? void 0 : _a.entries.filter(entry => entry.kind !== 'warning')) !== null && _b !== void 0 ? _b : [];
                            }
                            catch (_g) { }
                        }
                    }
                    {
                        const searchText = vue_typescript_1.SearchTexts.EmitCompletion(tag.name);
                        let offset = file.content.indexOf(searchText);
                        if (offset >= 0) {
                            offset += searchText.length;
                            try {
                                on = (_d = (_c = options.tsRuntime.getTsLs().getCompletionsAtPosition(file.fileName, offset, undefined)) === null || _c === void 0 ? void 0 : _c.entries.filter(entry => entry.kind !== 'warning')) !== null && _d !== void 0 ? _d : [];
                            }
                            catch (_h) { }
                        }
                    }
                    cache.set(tag.name, { item: tag.item, bind, on });
                }
                try {
                    const globalBind = (_f = (_e = options.tsRuntime.getTsLs().getCompletionsAtPosition(file.fileName, file.content.indexOf(vue_typescript_1.SearchTexts.GlobalAttrs), undefined)) === null || _e === void 0 ? void 0 : _e.entries.filter(entry => entry.kind !== 'warning')) !== null && _f !== void 0 ? _f : [];
                    cache.set('*', { item: undefined, bind: globalBind, on: [] });
                }
                catch (_j) { }
            }
            componentCompletionDataCache.set(templateData, cache);
        }
        return cache;
    }
}
exports.default = useVueTemplateLanguagePlugin;
function createInternalItemId(type, args) {
    return '__VLS_::' + type + '::' + args.join(',');
}
function readInternalItemId(key) {
    if (key.startsWith('__VLS_::')) {
        const strs = key.split('::');
        return {
            type: strs[1],
            args: strs[2].split(','),
        };
    }
}
function getReplacement(list, doc) {
    for (const item of list.items) {
        if (item.textEdit && 'range' in item.textEdit) {
            return {
                item: item,
                textEdit: item.textEdit,
                text: doc.getText(item.textEdit.range)
            };
        }
    }
}
//# sourceMappingURL=vue-template.js.map