"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.register = void 0;
const vscode = require("vscode-languageserver-protocol");
const shared = require("@volar/shared");
const featureWorkers_1 = require("../utils/featureWorkers");
function register(context) {
    return (uri, position) => {
        return (0, featureWorkers_1.languageFeatureWorker)(context, uri, position, function* (position, sourceMap) {
            for (const [mappedRange] of sourceMap.getMappedRanges(position, position, data => !!data.capabilities.basic)) {
                yield mappedRange.start;
            }
        }, (plugin, document, position) => { var _a; return (_a = plugin.doHover) === null || _a === void 0 ? void 0 : _a.call(plugin, document, position); }, (data, sourceMap) => {
            var _a;
            if (!sourceMap)
                return data;
            if (!data.range)
                return data;
            const range = (_a = sourceMap.getSourceRange(data.range.start, data.range.end)) === null || _a === void 0 ? void 0 : _a[0];
            if (range) {
                data.range = range;
                return data;
            }
        }, hovers => {
            var _a, _b;
            return ({
                contents: hovers.map(getHoverTexts).flat(),
                range: (_b = (_a = hovers.find(hover => hover.range && shared.isInsideRange(hover.range, { start: position, end: position }))) === null || _a === void 0 ? void 0 : _a.range) !== null && _b !== void 0 ? _b : hovers[0].range,
            });
        });
    };
}
exports.register = register;
function getHoverTexts(hover) {
    if (!hover) {
        return [];
    }
    if (typeof hover.contents === 'string') {
        return [hover.contents];
    }
    if (vscode.MarkupContent.is(hover.contents)) {
        return [hover.contents.value];
    }
    if (Array.isArray(hover.contents)) {
        return hover.contents;
    }
    return [hover.contents.value];
}
//# sourceMappingURL=hover.js.map