"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.register = void 0;
const typescript_1 = require("../plugins/typescript");
const dedupe = require("../utils/dedupe");
const featureWorkers_1 = require("../utils/featureWorkers");
function register(context) {
    const responseCache = new Map();
    const nonTsCache = new Map();
    const scriptTsCache_semantic = new Map();
    const scriptTsCache_declaration = new Map();
    const scriptTsCache_syntactic = new Map();
    const scriptTsCache_suggestion = new Map();
    return (uri, response, isCancel) => __awaiter(this, void 0, void 0, function* () {
        var _a;
        const cache = (_a = responseCache.get(uri)) !== null && _a !== void 0 ? _a : responseCache.set(uri, {
            nonTs: [],
            tsSemantic: [],
            tsDeclaration: [],
            tsSuggestion: [],
            tsSyntactic: [],
        }).get(uri);
        let errorsDirty = false; // avoid cache error range jitter
        yield worker(false, {
            declaration: true,
            semantic: true,
            suggestion: true,
            syntactic: true,
        }, nonTsCache, errors => cache.nonTs = errors !== null && errors !== void 0 ? errors : []);
        doResponse();
        yield worker(true, { syntactic: true }, scriptTsCache_syntactic, errors => cache.tsSyntactic = errors !== null && errors !== void 0 ? errors : []);
        yield worker(true, { suggestion: true }, scriptTsCache_suggestion, errors => cache.tsSuggestion = errors !== null && errors !== void 0 ? errors : []);
        doResponse();
        yield worker(true, { semantic: true }, scriptTsCache_semantic, errors => cache.tsSemantic = errors !== null && errors !== void 0 ? errors : []);
        doResponse();
        yield worker(true, { declaration: true }, scriptTsCache_declaration, errors => cache.tsDeclaration = errors !== null && errors !== void 0 ? errors : []);
        return getErrors();
        function doResponse() {
            if (errorsDirty) {
                response === null || response === void 0 ? void 0 : response(getErrors());
                errorsDirty = false;
            }
        }
        function getErrors() {
            return [
                ...cache.nonTs,
                ...cache.tsSyntactic,
                ...cache.tsSuggestion,
                ...cache.tsSemantic,
                ...cache.tsDeclaration,
            ];
        }
        function worker(isTs, options, cacheMap, response) {
            return __awaiter(this, void 0, void 0, function* () {
                const result = yield (0, featureWorkers_1.languageFeatureWorker)(context, uri, true, function* (arg, sourceMap) {
                    if (sourceMap.embeddedFile.capabilities.diagnostics && sourceMap.embeddedFile.isTsHostFile === isTs) {
                        yield arg;
                    }
                }, (plugin, document, arg, sourceMap) => __awaiter(this, void 0, void 0, function* () {
                    var _a, _b, _c, _d;
                    // avoid duplicate errors from vue plugin & typescript plugin
                    if ((0, typescript_1.isTsDocument)(document) !== isTs)
                        return;
                    if (yield (isCancel === null || isCancel === void 0 ? void 0 : isCancel()))
                        return;
                    const pluginId = context.getPluginId(plugin);
                    const pluginCache = (_a = cacheMap.get(pluginId)) !== null && _a !== void 0 ? _a : cacheMap.set(pluginId, new Map()).get(pluginId);
                    const cache = pluginCache.get(document.uri);
                    const tsProjectVersion = isTs ? (_c = (_b = context.getTsLs().__internal__.host).getProjectVersion) === null || _c === void 0 ? void 0 : _c.call(_b) : undefined;
                    if (!isTs) {
                        if (cache && cache.documentVersion === document.version) {
                            return cache.errors;
                        }
                    }
                    else {
                        if (options.declaration || options.semantic) {
                            if (cache && cache.documentVersion === document.version && cache.tsProjectVersion === tsProjectVersion) {
                                return cache.errors;
                            }
                        }
                        else {
                            if (cache && cache.documentVersion === document.version) {
                                return cache.errors;
                            }
                        }
                    }
                    const errors = yield ((_d = plugin.doValidation) === null || _d === void 0 ? void 0 : _d.call(plugin, document, options));
                    errorsDirty = true;
                    pluginCache.set(document.uri, {
                        documentVersion: document.version,
                        errors,
                        tsProjectVersion,
                    });
                    return errors;
                }), (errors, sourceMap) => transformErrorRange(sourceMap, errors), arr => dedupe.withDiagnostics(arr.flat()));
                if (!(yield (isCancel === null || isCancel === void 0 ? void 0 : isCancel())))
                    response(result);
            });
        }
    });
    function transformErrorRange(sourceMap, errors) {
        var _a, _b, _c;
        const result = [];
        for (const error of errors) {
            const _error = Object.assign({}, error);
            if (sourceMap) {
                let sourceRange = (_a = sourceMap.getSourceRange(error.range.start, error.range.end, data => !!data.capabilities.diagnostic)) === null || _a === void 0 ? void 0 : _a[0];
                // fix https://github.com/johnsoncodehk/volar/issues/1205
                // fix https://github.com/johnsoncodehk/volar/issues/1264
                if (!sourceRange) {
                    const start = (_b = sourceMap.getSourceRange(error.range.start, error.range.start, data => !!data.capabilities.diagnostic)) === null || _b === void 0 ? void 0 : _b[0].start;
                    const end = (_c = sourceMap.getSourceRange(error.range.end, error.range.end, data => !!data.capabilities.diagnostic)) === null || _c === void 0 ? void 0 : _c[0].end;
                    if (start && end) {
                        sourceRange = { start, end };
                    }
                }
                if (!sourceRange)
                    continue;
                _error.range = sourceRange;
            }
            if (_error.relatedInformation) {
                const relatedInfos = [];
                for (const info of _error.relatedInformation) {
                    for (const sourceLoc of context.vueDocuments.fromEmbeddedLocation(info.location.uri, info.location.range.start, info.location.range.end, data => !!data.capabilities.diagnostic)) {
                        relatedInfos.push({
                            location: {
                                uri: sourceLoc.uri,
                                range: sourceLoc.range,
                            },
                            message: info.message,
                        });
                        break;
                    }
                }
                _error.relatedInformation = relatedInfos;
            }
            result.push(_error);
        }
        return result;
    }
}
exports.register = register;
//# sourceMappingURL=validation.js.map