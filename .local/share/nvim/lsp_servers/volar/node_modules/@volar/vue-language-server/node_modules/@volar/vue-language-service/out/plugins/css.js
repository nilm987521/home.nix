"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const vue_language_service_types_1 = require("@volar/vue-language-service-types");
const css = require("vscode-css-languageservice");
const vscode_languageserver_textdocument_1 = require("vscode-languageserver-textdocument");
const shared = require("@volar/shared");
const vscode = require("vscode-languageserver-protocol");
const wordPatterns = {
    css: /(#?-?\d*\.\d\w*%?)|(::?[\w-]*(?=[^,{;]*[,{]))|(([@#.!])?[\w-?]+%?|[@#!.])/g,
    less: /(#?-?\d*\.\d\w*%?)|(::?[\w-]+(?=[^,{;]*[,{]))|(([@#.!])?[\w-?]+%?|[@#!.])/g,
    scss: /(#?-?\d*\.\d\w*%?)|(::?[\w-]*(?=[^,{;]*[,{]))|(([@$#.!])?[\w-?]+%?|[@#!$.])/g,
    postcss: /(#?-?\d*\.\d\w*%?)|(::?[\w-]*(?=[^,{;]*[,{]))|(([@$#.!])?[\w-?]+%?|[@#!$.])/g, // scss
};
function default_1(options) {
    const cssLs = css.getCSSLanguageService({ fileSystemProvider: options.fileSystemProvider });
    const scssLs = css.getSCSSLanguageService({ fileSystemProvider: options.fileSystemProvider });
    const lessLs = css.getLESSLanguageService({ fileSystemProvider: options.fileSystemProvider });
    const postcssLs = Object.assign(Object.assign({}, scssLs), { doValidation: (document, stylesheet, documentSettings) => {
            let errors = scssLs.doValidation(document, stylesheet, documentSettings);
            errors = errors.filter(error => error.code !== 'css-semicolonexpected');
            errors = errors.filter(error => error.code !== 'css-ruleorselectorexpected');
            errors = errors.filter(error => error.code !== 'unknownAtRules');
            return errors;
        } });
    const stylesheets = new WeakMap();
    let inited = false;
    return {
        getStylesheet,
        getCssLs,
        complete: {
            // https://github.com/microsoft/vscode/blob/09850876e652688fb142e2e19fd00fd38c0bc4ba/extensions/css-language-features/server/src/cssServer.ts#L97
            triggerCharacters: ['/', '-', ':'],
            on(document, position, context) {
                return __awaiter(this, void 0, void 0, function* () {
                    return worker(document, (stylesheet, cssLs) => __awaiter(this, void 0, void 0, function* () {
                        var _a, _b, _c;
                        if (!options.documentContext)
                            return;
                        const wordPattern = (_a = wordPatterns[document.languageId]) !== null && _a !== void 0 ? _a : wordPatterns.css;
                        const wordStart = (_b = shared.getWordRange(wordPattern, position, document)) === null || _b === void 0 ? void 0 : _b.start; // TODO: use end?
                        const wordRange = vscode.Range.create(wordStart !== null && wordStart !== void 0 ? wordStart : position, position);
                        const settings = yield ((_c = (0, vue_language_service_types_1.useConfigurationHost)()) === null || _c === void 0 ? void 0 : _c.getConfiguration(document.languageId, document.uri));
                        const cssResult = yield cssLs.doComplete2(document, position, stylesheet, options.documentContext, settings === null || settings === void 0 ? void 0 : settings.completion);
                        if (cssResult) {
                            for (const item of cssResult.items) {
                                if (item.textEdit)
                                    continue;
                                // track https://github.com/microsoft/vscode-css-languageservice/issues/265
                                const newText = item.insertText || item.label;
                                item.textEdit = vscode.TextEdit.replace(wordRange, newText);
                            }
                        }
                        return cssResult;
                    }));
                });
            },
        },
        rename: {
            prepare(document, position) {
                return worker(document, (stylesheet, cssLs) => {
                    var _a;
                    const wordPattern = (_a = wordPatterns[document.languageId]) !== null && _a !== void 0 ? _a : wordPatterns.css;
                    const wordRange = shared.getWordRange(wordPattern, position, document);
                    return wordRange;
                });
            },
            on(document, position, newName) {
                return worker(document, (stylesheet, cssLs) => {
                    return cssLs.doRename(document, position, newName, stylesheet);
                });
            },
        },
        codeAction: {
            on(document, range, context) {
                return worker(document, (stylesheet, cssLs) => {
                    return cssLs.doCodeActions2(document, range, context, stylesheet);
                });
            },
        },
        definition: {
            on(document, position) {
                return worker(document, (stylesheet, cssLs) => {
                    const location = cssLs.findDefinition(document, position, stylesheet);
                    if (location) {
                        return [vscode.LocationLink.create(location.uri, location.range, location.range)];
                    }
                });
            },
        },
        doValidation(document) {
            return __awaiter(this, void 0, void 0, function* () {
                return worker(document, (stylesheet, cssLs) => __awaiter(this, void 0, void 0, function* () {
                    var _a;
                    const settings = yield ((_a = (0, vue_language_service_types_1.useConfigurationHost)()) === null || _a === void 0 ? void 0 : _a.getConfiguration(document.languageId, document.uri));
                    return cssLs.doValidation(document, stylesheet, settings);
                }));
            });
        },
        doHover(document, position) {
            return __awaiter(this, void 0, void 0, function* () {
                return worker(document, (stylesheet, cssLs) => __awaiter(this, void 0, void 0, function* () {
                    var _a;
                    const settings = yield ((_a = (0, vue_language_service_types_1.useConfigurationHost)()) === null || _a === void 0 ? void 0 : _a.getConfiguration(document.languageId, document.uri));
                    return cssLs.doHover(document, position, stylesheet, settings === null || settings === void 0 ? void 0 : settings.hover);
                }));
            });
        },
        findReferences(document, position) {
            return worker(document, (stylesheet, cssLs) => {
                return cssLs.findReferences(document, position, stylesheet);
            });
        },
        findDocumentHighlights(document, position) {
            return worker(document, (stylesheet, cssLs) => {
                return cssLs.findDocumentHighlights(document, position, stylesheet);
            });
        },
        findDocumentLinks(document) {
            return worker(document, (stylesheet, cssLs) => {
                if (!options.documentContext)
                    return;
                return cssLs.findDocumentLinks(document, stylesheet, options.documentContext);
            });
        },
        findDocumentSymbols(document) {
            return worker(document, (stylesheet, cssLs) => {
                return cssLs.findDocumentSymbols(document, stylesheet);
            });
        },
        findDocumentColors(document) {
            return worker(document, (stylesheet, cssLs) => {
                return cssLs.findDocumentColors(document, stylesheet);
            });
        },
        getColorPresentations(document, color, range) {
            return worker(document, (stylesheet, cssLs) => {
                return cssLs.getColorPresentations(document, stylesheet, color, range);
            });
        },
        getFoldingRanges(document) {
            return worker(document, (stylesheet, cssLs) => {
                return cssLs.getFoldingRanges(document, stylesheet);
            });
        },
        getSelectionRanges(document, positions) {
            return worker(document, (stylesheet, cssLs) => {
                return cssLs.getSelectionRanges(document, positions, stylesheet);
            });
        },
        format(document, range, options) {
            return __awaiter(this, void 0, void 0, function* () {
                return worker(document, (stylesheet, cssLs) => __awaiter(this, void 0, void 0, function* () {
                    var _a;
                    const options_2 = yield ((_a = (0, vue_language_service_types_1.useConfigurationHost)()) === null || _a === void 0 ? void 0 : _a.getConfiguration('css.format', document.uri));
                    const edits = cssLs.format(document, range, Object.assign(Object.assign({}, options_2), options));
                    let newText = vscode_languageserver_textdocument_1.TextDocument.applyEdits(document, edits);
                    // fix https://github.com/johnsoncodehk/volar/issues/1155
                    if (!newText.startsWith('\n'))
                        newText = '\n' + newText;
                    if (!newText.endsWith('\n'))
                        newText = newText + '\n';
                    if (newText === document.getText())
                        return [];
                    return [vscode.TextEdit.replace({
                            start: document.positionAt(0),
                            end: document.positionAt(document.getText().length),
                        }, newText)];
                }));
            });
        },
    };
    function initCustomData() {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            if (!inited) {
                (_a = (0, vue_language_service_types_1.useConfigurationHost)()) === null || _a === void 0 ? void 0 : _a.onDidChangeConfiguration(() => __awaiter(this, void 0, void 0, function* () {
                    const customData = yield getCustomData();
                    cssLs.setDataProviders(true, customData);
                    scssLs.setDataProviders(true, customData);
                    lessLs.setDataProviders(true, customData);
                }));
                const customData = yield getCustomData();
                cssLs.setDataProviders(true, customData);
                scssLs.setDataProviders(true, customData);
                lessLs.setDataProviders(true, customData);
                inited = true;
            }
        });
    }
    function getCustomData() {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const configHost = (0, vue_language_service_types_1.useConfigurationHost)();
            if (configHost) {
                const paths = new Set();
                const customData = (_a = yield configHost.getConfiguration('css.customData')) !== null && _a !== void 0 ? _a : [];
                const rootPaths = configHost.rootUris.map(shared.uriToFsPath);
                for (const customDataPath of customData) {
                    try {
                        const jsonPath = require.resolve(customDataPath, { paths: rootPaths });
                        paths.add(jsonPath);
                    }
                    catch (error) {
                        console.error(error);
                    }
                }
                const newData = [];
                for (const path of paths) {
                    try {
                        newData.push(css.newCSSDataProvider(require(path)));
                    }
                    catch (error) {
                        console.error(error);
                    }
                }
                return newData;
            }
            return [];
        });
    }
    function getCssLs(lang) {
        switch (lang) {
            case 'css': return cssLs;
            case 'scss': return scssLs;
            case 'less': return lessLs;
            case 'postcss': return postcssLs;
        }
    }
    function getStylesheet(document) {
        const cache = stylesheets.get(document);
        if (cache) {
            const [cacheVersion, cacheStylesheet] = cache;
            if (cacheVersion === document.version) {
                return cacheStylesheet;
            }
        }
        const cssLs = getCssLs(document.languageId);
        if (!cssLs)
            return;
        const stylesheet = cssLs.parseStylesheet(document);
        stylesheets.set(document, [document.version, stylesheet]);
        return stylesheet;
    }
    function worker(document, callback) {
        return __awaiter(this, void 0, void 0, function* () {
            const stylesheet = getStylesheet(document);
            if (!stylesheet)
                return;
            const cssLs = getCssLs(document.languageId);
            if (!cssLs)
                return;
            yield initCustomData();
            return callback(stylesheet, cssLs);
        });
    }
}
exports.default = default_1;
;
//# sourceMappingURL=css.js.map