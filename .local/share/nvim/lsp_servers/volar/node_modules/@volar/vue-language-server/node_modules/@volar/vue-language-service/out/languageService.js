"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createLanguageService = exports.getSemanticTokenLegend = void 0;
const shared = require("@volar/shared");
const ts2 = require("@volar/typescript-language-service");
const vue_language_service_types_1 = require("@volar/vue-language-service-types");
const vue_typescript_1 = require("@volar/vue-typescript");
const shared_1 = require("@vue/shared");
const upath = require("upath");
const vscode_languageserver_textdocument_1 = require("vscode-languageserver-textdocument");
const stylesheetExtra_1 = require("./stylesheetExtra");
const css_1 = require("./plugins/css");
const emmet_1 = require("./plugins/emmet");
const html_1 = require("./plugins/html");
const json_1 = require("./plugins/json");
const pug_1 = require("./plugins/pug");
const typescript_1 = require("./plugins/typescript");
const tagNameCase = require("./ideFeatures/tagNameCase");
const autoInsert = require("./languageFeatures/autoInsert");
const callHierarchy = require("./languageFeatures/callHierarchy");
const codeActionResolve = require("./languageFeatures/codeActionResolve");
const codeActions = require("./languageFeatures/codeActions");
const codeLens = require("./languageFeatures/codeLens");
const codeLensResolve = require("./languageFeatures/codeLensResolve");
const completions = require("./languageFeatures/complete");
const completionResolve = require("./languageFeatures/completeResolve");
const definition = require("./languageFeatures/definition");
const documentHighlight = require("./languageFeatures/documentHighlights");
const documentLink = require("./languageFeatures/documentLinks");
const semanticTokens = require("./languageFeatures/documentSemanticTokens");
const executeCommand = require("./languageFeatures/executeCommand");
const fileRename = require("./languageFeatures/fileRename");
const hover = require("./languageFeatures/hover");
const references = require("./languageFeatures/references");
const rename = require("./languageFeatures/rename");
const renamePrepare = require("./languageFeatures/renamePrepare");
const signatureHelp = require("./languageFeatures/signatureHelp");
const diagnostics = require("./languageFeatures/validation");
const workspaceSymbol = require("./languageFeatures/workspaceSymbols");
const inlayHints = require("./languageFeatures/inlayHints");
const tsConfigs_1 = require("./tsConfigs");
const vueDocuments_1 = require("./vueDocuments");
const vue_autoinsert_dotvalue_1 = require("./plugins/vue-autoinsert-dotvalue");
const vue_convert_htmlpug_1 = require("./plugins/vue-convert-htmlpug");
const vue_codelens_references_1 = require("./plugins/vue-codelens-references");
const vue_convert_refsugar_1 = require("./plugins/vue-convert-refsugar");
const vue_convert_scriptsetup_1 = require("./plugins/vue-convert-scriptsetup");
const vue_convert_tagcasing_1 = require("./plugins/vue-convert-tagcasing");
const vue_1 = require("./plugins/vue");
const vue_template_1 = require("./plugins/vue-template");
function getSemanticTokenLegend() {
    const tsLegend = ts2.getSemanticTokenLegend();
    const tokenTypesLegend = [
        ...tsLegend.tokenTypes,
        ...vue_template_1.semanticTokenTypes,
    ];
    const semanticTokenLegend = {
        tokenTypes: tokenTypesLegend,
        tokenModifiers: tsLegend.tokenModifiers,
    };
    return semanticTokenLegend;
}
exports.getSemanticTokenLegend = getSemanticTokenLegend;
function createLanguageService({ typescript: ts }, vueLsHost, fileSystemProvider, schemaRequestService, configurationHost, customPlugins, getNameCases) {
    (0, vue_language_service_types_1.setCurrentConfigurationHost)(configurationHost); // TODO
    const tsRuntime = (0, vue_typescript_1.createTypeScriptRuntime)({
        typescript: ts,
        baseCssModuleType: 'Record<string, string>',
        getCssClasses: ef => stylesheetExtra.getCssClasses(ef),
        vueLsHost: vueLsHost,
        isTsPlugin: false,
    });
    const vueDocuments = (0, vueDocuments_1.parseVueDocuments)(tsRuntime.vueFiles);
    const tsSettings = (0, tsConfigs_1.getTsSettings)(configurationHost);
    const documentContext = getDocumentContext();
    const tsLs = ts2.createLanguageService(ts, tsRuntime.getTsLsHost(), tsRuntime.getTsLs(), tsSettings);
    const blockingRequests = new Set();
    const documents = new WeakMap();
    const documentVersions = new Map();
    // plugins
    const vuePlugin = (0, vue_1.default)({
        getVueDocument: (document) => vueDocuments.get(document.uri),
        tsLs,
    });
    const vueTemplateHtmlPlugin = _useVueTemplateLanguagePlugin('html', (0, html_1.default)({
        documentContext,
        fileSystemProvider,
    }));
    const vueTemplatePugPlugin = _useVueTemplateLanguagePlugin('jade', (0, pug_1.default)({
        configurationHost,
        htmlPlugin: vueTemplateHtmlPlugin,
        documentContext,
    }));
    const cssPlugin = (0, css_1.default)({
        documentContext,
        fileSystemProvider,
    });
    const jsonPlugin = (0, json_1.default)({
        schema: undefined,
        schemaRequestService,
    });
    const emmetPlugin = (0, emmet_1.default)();
    const scriptTsPlugin = useTsPlugins(tsLs, false, uri => (uri.indexOf('.__VLS_template') === -1 ? {
        // includeCompletionsForModuleExports: true, // set in server/src/tsConfigs.ts
        includeCompletionsWithInsertText: true, // if missing, { 'aaa-bbb': any, ccc: any } type only has result ['ccc']
    } : {
        // includeCompletionsForModuleExports: true, // set in server/src/tsConfigs.ts
        includeCompletionsWithInsertText: true,
        quotePreference: 'single',
        includeCompletionsForModuleExports: false,
        includeCompletionsForImportStatements: false,
    }));
    const autoDotValuePlugin = (0, vue_autoinsert_dotvalue_1.default)({
        ts,
        getTsLs: () => tsLs,
    });
    const referencesCodeLensPlugin = (0, vue_codelens_references_1.default)({
        getVueDocument: (uri) => vueDocuments.get(uri),
        findReference: (...args) => __awaiter(this, void 0, void 0, function* () { return findReferences_internal(...args); }),
    });
    const htmlPugConversionsPlugin = (0, vue_convert_htmlpug_1.default)({
        getVueDocument: (uri) => vueDocuments.get(uri),
    });
    const scriptSetupConversionsPlugin = (0, vue_convert_scriptsetup_1.default)({
        ts,
        getVueDocument: (uri) => vueDocuments.get(uri),
        doCodeActions: (...args) => __awaiter(this, void 0, void 0, function* () { return doCodeActions_internal(...args); }),
        doCodeActionResolve: (...args) => __awaiter(this, void 0, void 0, function* () { return doCodeActionResolve_internal(...args); }),
    });
    const refSugarConversionsPlugin = (0, vue_convert_refsugar_1.default)({
        ts,
        getVueDocument: (uri) => vueDocuments.get(uri),
        doCodeActions: (...args) => __awaiter(this, void 0, void 0, function* () { return doCodeActions_internal(...args); }),
        doCodeActionResolve: (...args) => __awaiter(this, void 0, void 0, function* () { return doCodeActionResolve_internal(...args); }),
        findReferences: (...args) => __awaiter(this, void 0, void 0, function* () { return findReferences_internal(...args); }),
        doValidation: (...args) => __awaiter(this, void 0, void 0, function* () { return doValidation_internal(...args); }),
        doRename: (...args) => __awaiter(this, void 0, void 0, function* () { return doRename_internal(...args); }),
        findTypeDefinition: (...args) => __awaiter(this, void 0, void 0, function* () { return findTypeDefinition_internal(...args); }),
        scriptTsLs: tsLs,
    });
    const tagNameCasingConversionsPlugin = (0, vue_convert_tagcasing_1.default)({
        getVueDocument: (uri) => vueDocuments.get(uri),
        findReferences: (...args) => __awaiter(this, void 0, void 0, function* () { return findReferences_internal(...args); }),
    });
    const allPlugins = [
        ...customPlugins,
        vuePlugin,
        cssPlugin,
        vueTemplateHtmlPlugin,
        vueTemplatePugPlugin,
        jsonPlugin,
        emmetPlugin,
        autoDotValuePlugin,
        referencesCodeLensPlugin,
        htmlPugConversionsPlugin,
        scriptSetupConversionsPlugin,
        refSugarConversionsPlugin,
        tagNameCasingConversionsPlugin,
        scriptTsPlugin,
    ];
    const stylesheetExtra = (0, stylesheetExtra_1.createStylesheetExtra)(cssPlugin);
    const context = {
        vueDocuments,
        getTsLs: () => tsLs,
        getTextDocument,
        getPlugins: () => [
            ...customPlugins,
            vuePlugin,
            cssPlugin,
            vueTemplateHtmlPlugin,
            vueTemplatePugPlugin,
            jsonPlugin,
            referencesCodeLensPlugin,
            htmlPugConversionsPlugin,
            scriptSetupConversionsPlugin,
            refSugarConversionsPlugin,
            tagNameCasingConversionsPlugin,
            scriptTsPlugin,
            autoDotValuePlugin,
            // put emmet plugin last to fix https://github.com/johnsoncodehk/volar/issues/1088
            emmetPlugin,
        ],
        getPluginId: plugin => allPlugins.indexOf(plugin),
        getPluginById: id => allPlugins[id],
    };
    const _callHierarchy = callHierarchy.register(context);
    const findReferences_internal = defineInternalApi(references.register(context));
    const doCodeActions_internal = defineInternalApi(codeActions.register(context));
    const doCodeActionResolve_internal = defineInternalApi(codeActionResolve.register(context));
    const doValidation_internal = defineInternalApi(diagnostics.register(context));
    const doRename_internal = defineInternalApi(rename.register(context));
    const findTypeDefinition_internal = defineInternalApi(definition.register(context, 'findTypeDefinition', data => !!data.capabilities.definitions, data => !!data.capabilities.definitions));
    return {
        doValidation: defineApi(diagnostics.register(context), false),
        findReferences: defineApi(references.register(context)),
        findDefinition: defineApi(definition.register(context, 'findDefinition', data => !!data.capabilities.definitions, data => !!data.capabilities.definitions)),
        findTypeDefinition: defineApi(definition.register(context, 'findTypeDefinition', data => !!data.capabilities.definitions, data => !!data.capabilities.definitions)),
        findImplementations: defineApi(definition.register(context, 'findImplementations', data => !!data.capabilities.references, data => false)),
        prepareRename: defineApi(renamePrepare.register(context)),
        doRename: defineApi(rename.register(context)),
        getEditsForFileRename: defineApi(fileRename.register(context)),
        getSemanticTokens: defineApi(semanticTokens.register(context)),
        doHover: defineApi(hover.register(context)),
        doComplete: defineApi(completions.register(context)),
        doCodeActions: defineApi(codeActions.register(context)),
        doCodeActionResolve: defineApi(codeActionResolve.register(context)),
        doCompletionResolve: defineApi(completionResolve.register(context)),
        getSignatureHelp: defineApi(signatureHelp.register(context)),
        doCodeLens: defineApi(codeLens.register(context)),
        doCodeLensResolve: defineApi(codeLensResolve.register(context)),
        findDocumentHighlights: defineApi(documentHighlight.register(context)),
        findDocumentLinks: defineApi(documentLink.register(context)),
        findWorkspaceSymbols: defineApi(workspaceSymbol.register(context)),
        doAutoInsert: defineApi(autoInsert.register(context)),
        doExecuteCommand: defineApi(executeCommand.register(context)),
        getInlayHints: defineApi(inlayHints.register(context)),
        callHierarchy: {
            doPrepare: defineApi(_callHierarchy.doPrepare),
            getIncomingCalls: defineApi(_callHierarchy.getIncomingCalls),
            getOutgoingCalls: defineApi(_callHierarchy.getOutgoingCalls),
        },
        dispose: () => {
            tsRuntime.dispose();
        },
        __internal__: {
            tsRuntime,
            rootPath: vueLsHost.getCurrentDirectory(),
            context,
            getContext: defineApi(() => context),
            // getD3: defineApi(d3.register(context), true), // unused for now
            detectTagNameCase: defineApi(tagNameCase.register(context)),
        },
    };
    function getDocumentContext() {
        const compilerHost = ts.createCompilerHost(vueLsHost.getCompilationSettings());
        const documentContext = {
            resolveReference(ref, base) {
                var _a, _b;
                const isUri = base.indexOf('://') >= 0;
                const resolveResult = ts.resolveModuleName(ref, isUri ? shared.uriToFsPath(base) : base, vueLsHost.getCompilationSettings(), compilerHost);
                const failedLookupLocations = resolveResult.failedLookupLocations;
                const dirs = new Set();
                const fileExists = (_a = vueLsHost.fileExists) !== null && _a !== void 0 ? _a : ts.sys.fileExists;
                const directoryExists = (_b = vueLsHost.directoryExists) !== null && _b !== void 0 ? _b : ts.sys.directoryExists;
                for (const failed of failedLookupLocations) {
                    let path = failed;
                    const fileName = upath.basename(path);
                    if (fileName === 'index.d.ts' || fileName === '*.d.ts') {
                        dirs.add(upath.dirname(path));
                    }
                    if (path.endsWith('.d.ts')) {
                        path = upath.removeExt(upath.removeExt(path, '.ts'), '.d');
                    }
                    else {
                        continue;
                    }
                    if (fileExists(path)) {
                        return isUri ? shared.fsPathToUri(path) : path;
                    }
                }
                for (const dir of dirs) {
                    if (directoryExists(dir)) {
                        return isUri ? shared.fsPathToUri(dir) : dir;
                    }
                }
                return undefined;
            },
        };
        return documentContext;
    }
    function getTextDocument(uri) {
        var _a;
        const fileName = shared.uriToFsPath(uri);
        const scriptSnapshot = vueLsHost.getScriptSnapshot(fileName);
        if (scriptSnapshot) {
            let document = documents.get(scriptSnapshot);
            if (!document) {
                const newVersion = ((_a = documentVersions.get(uri.toLowerCase())) !== null && _a !== void 0 ? _a : 0) + 1;
                documentVersions.set(uri.toLowerCase(), newVersion);
                document = vscode_languageserver_textdocument_1.TextDocument.create(uri, uri.endsWith('.vue') ? 'vue' : 'typescript', // TODO
                newVersion, scriptSnapshot.getText(0, scriptSnapshot.getLength()));
                documents.set(scriptSnapshot, document);
            }
            return document;
        }
    }
    function _useVueTemplateLanguagePlugin(languageId, templateLanguagePlugin) {
        return (0, vue_template_1.default)({
            ts,
            templateLanguagePlugin,
            getSemanticTokenLegend,
            getScanner: (document) => {
                if (document.languageId === 'html') {
                    return templateLanguagePlugin.htmlLs.createScanner(document.getText());
                }
                else if (document.languageId === 'jade') {
                    const pugDocument = 'getPugDocument' in templateLanguagePlugin ? templateLanguagePlugin.getPugDocument(document) : undefined;
                    if (pugDocument) {
                        return 'pugLs' in templateLanguagePlugin ? templateLanguagePlugin.pugLs.createScanner(pugDocument) : undefined;
                    }
                }
            },
            tsLs,
            isSupportedDocument: (document) => document.languageId === languageId,
            getNameCases,
            vueLsHost,
            vueDocuments,
            tsSettings,
            tsRuntime,
        });
    }
    function useTsPlugins(tsLs, isTemplatePlugin, getBaseCompletionOptions) {
        const _languageSupportPlugin = (0, typescript_1.default)({
            tsVersion: ts.version,
            getTsLs: () => tsLs,
            getBaseCompletionOptions,
        });
        const languageSupportPlugin = isTemplatePlugin ? Object.assign(Object.assign({}, _languageSupportPlugin), { complete: Object.assign(Object.assign({}, _languageSupportPlugin.complete), { on(textDocument, position, context) {
                    var _a, _b, _c;
                    return __awaiter(this, void 0, void 0, function* () {
                        const tsComplete = yield ((_b = (_a = _languageSupportPlugin.complete) === null || _a === void 0 ? void 0 : _a.on) === null || _b === void 0 ? void 0 : _b.call(_a, textDocument, position, context));
                        if (tsComplete) {
                            const sortTexts = (_c = shared.getTsCompletions(ts)) === null || _c === void 0 ? void 0 : _c.SortText;
                            if (sortTexts) {
                                tsComplete.items = tsComplete.items.filter(tsItem => {
                                    if ((sortTexts.GlobalsOrKeywords !== undefined && tsItem.sortText === sortTexts.GlobalsOrKeywords)
                                        || (sortTexts.DeprecatedGlobalsOrKeywords !== undefined && tsItem.sortText === sortTexts.DeprecatedGlobalsOrKeywords)) {
                                        return (0, shared_1.isGloballyWhitelisted)(tsItem.label);
                                    }
                                    return true;
                                });
                            }
                        }
                        return tsComplete;
                    });
                } }) }) : _languageSupportPlugin;
        return languageSupportPlugin;
    }
    function defineApi(api, blockNewRequest = true) {
        const handler = {
            apply(target, thisArg, argumentsList) {
                return __awaiter(this, void 0, void 0, function* () {
                    for (const runningRequest of blockingRequests) {
                        yield runningRequest;
                    }
                    tsRuntime.update();
                    const runner = target.apply(thisArg, argumentsList);
                    if (blockNewRequest && runner instanceof Promise) {
                        blockingRequests.add(runner);
                        runner.then(() => blockingRequests.delete(runner));
                    }
                    return runner;
                });
            }
        };
        return new Proxy(api, handler);
    }
    function defineInternalApi(api) {
        const handler = {
            apply(target, thisArg, argumentsList) {
                return __awaiter(this, void 0, void 0, function* () {
                    tsRuntime.update();
                    return target.apply(thisArg, argumentsList);
                });
            }
        };
        return new Proxy(api, handler);
    }
}
exports.createLanguageService = createLanguageService;
//# sourceMappingURL=languageService.js.map