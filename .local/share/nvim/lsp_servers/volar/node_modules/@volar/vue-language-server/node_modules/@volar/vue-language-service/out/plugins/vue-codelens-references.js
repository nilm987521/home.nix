"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.commands = void 0;
const vue_language_service_types_1 = require("@volar/vue-language-service-types");
const shared = require("@volar/shared");
const showReferencesCommand = 'volar.show-references';
exports.commands = [showReferencesCommand];
function default_1(options) {
    return {
        codeLens: {
            on(document) {
                return worker(document.uri, (vueDocument) => __awaiter(this, void 0, void 0, function* () {
                    var _a, _b;
                    const isEnabled = (_b = yield ((_a = (0, vue_language_service_types_1.useConfigurationHost)()) === null || _a === void 0 ? void 0 : _a.getConfiguration('volar.codeLens.references'))) !== null && _b !== void 0 ? _b : true;
                    if (!isEnabled)
                        return;
                    const result = [];
                    for (const sourceMap of vueDocument.getSourceMaps()) {
                        for (const mapping of sourceMap.mappings) {
                            if (!mapping.data.capabilities.referencesCodeLens)
                                continue;
                            const data = {
                                uri: document.uri,
                                vueTag: mapping.data.vueTag,
                                position: document.positionAt(mapping.sourceRange.start),
                            };
                            result.push({
                                range: {
                                    start: document.positionAt(mapping.sourceRange.start),
                                    end: document.positionAt(mapping.sourceRange.end),
                                },
                                data: data,
                            });
                        }
                    }
                    return result;
                }));
            },
            resolve(codeLens) {
                var _a, _b;
                return __awaiter(this, void 0, void 0, function* () {
                    const data = codeLens.data;
                    const vueDocument = options.getVueDocument(data.uri);
                    if (!vueDocument)
                        return codeLens;
                    const sourceMaps = vueDocument.getSourceMaps();
                    const references = (_a = yield options.findReference(data.uri, data.position)) !== null && _a !== void 0 ? _a : [];
                    const referencesInDifferentDocument = references.filter(reference => reference.uri !== data.uri // different file
                        || sourceMaps.some(sourceMap => sourceMap.getMappedRange(reference.range.start, reference.range.end, _data => _data.vueTag !== data.vueTag)) // different embedded document
                    );
                    const referencesCount = (_b = referencesInDifferentDocument.length) !== null && _b !== void 0 ? _b : 0;
                    codeLens.command = {
                        title: referencesCount === 1 ? '1 reference' : `${referencesCount} references`,
                        command: showReferencesCommand,
                        arguments: [data.uri, codeLens.range.start, references],
                    };
                    return codeLens;
                });
            },
        },
        doExecuteCommand(command, args, context) {
            if (command === showReferencesCommand) {
                const [uri, position, references] = args;
                context.sendNotification(shared.ShowReferencesNotification.type, {
                    textDocument: { uri },
                    position,
                    references,
                });
            }
        },
    };
    function worker(uri, callback) {
        const vueDocument = options.getVueDocument(uri);
        if (!vueDocument)
            return;
        return callback(vueDocument);
    }
}
exports.default = default_1;
//# sourceMappingURL=vue-codelens-references.js.map