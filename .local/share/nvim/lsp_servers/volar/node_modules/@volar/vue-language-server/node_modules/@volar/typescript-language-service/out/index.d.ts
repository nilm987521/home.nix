import * as vscode from 'vscode-languageserver-protocol';
import { TextDocument } from 'vscode-languageserver-textdocument';
import type * as ts from 'typescript/lib/tsserverlibrary';
export interface LanguageService extends ReturnType<typeof createLanguageService> {
}
export { getSemanticTokenLegend } from './services/semanticTokens';
export interface Settings {
    getFormatOptions?(document: TextDocument, options?: vscode.FormattingOptions): Promise<ts.FormatCodeSettings>;
    getPreferences?(document: TextDocument): Promise<ts.UserPreferences>;
}
export declare function createLanguageService(ts: typeof import('typescript/lib/tsserverlibrary'), host: ts.LanguageServiceHost, languageService: ts.LanguageService, settings: Settings): {
    findDefinition: (uri: string, position: vscode.Position) => vscode.LocationLink[];
    findTypeDefinition: (uri: string, position: vscode.Position) => vscode.LocationLink[];
    findReferences: (uri: string, position: vscode.Position) => vscode.Location[];
    findImplementations: (uri: string, position: vscode.Position) => vscode.LocationLink[];
    prepareRename: (uri: string, position: vscode.Position) => vscode.Range | vscode.ResponseError<void> | undefined;
    doRename: (uri: string, position: vscode.Position, newName: string) => Promise<vscode.WorkspaceEdit | undefined>;
    getEditsForFileRename: (oldUri: string, newUri: string) => Promise<vscode.WorkspaceEdit | undefined>;
    getCodeActions: (uri: string, range: vscode.Range, context: vscode.CodeActionContext) => Promise<vscode.CodeAction[] | undefined>;
    doCodeActionResolve: (codeAction: vscode.CodeAction) => Promise<vscode.CodeAction>;
    getInlayHints: (uri: string, range: vscode.Range) => Promise<vscode.InlayHint[] | undefined>;
    findDocumentHighlights: (uri: string, position: vscode.Position) => vscode.DocumentHighlight[];
    findDocumentSymbols: (uri: string) => vscode.SymbolInformation[];
    findWorkspaceSymbols: (query: string) => vscode.SymbolInformation[];
    doComplete: (uri: string, position: vscode.Position, options?: ts.GetCompletionsAtPositionOptions | undefined) => Promise<vscode.CompletionList | undefined>;
    doCompletionResolve: (item: vscode.CompletionItem, newPosition?: vscode.Position | undefined) => Promise<vscode.CompletionItem>;
    doDirectiveCommentComplete: (uri: string, position: vscode.Position) => vscode.CompletionItem[] | undefined;
    doJsDocComplete: (uri: string, position: vscode.Position) => vscode.CompletionItem | undefined;
    doHover: (uri: string, position: vscode.Position, documentOnly?: boolean) => vscode.Hover | undefined;
    doFormatting: {
        onRange: (uri: string, options: vscode.FormattingOptions, range?: vscode.Range | undefined) => Promise<vscode.TextEdit[]>;
        onType: (uri: string, options: vscode.FormattingOptions, position: vscode.Position, key: string) => Promise<vscode.TextEdit[]>;
    };
    getSignatureHelp: (uri: string, position: vscode.Position, context?: vscode.SignatureHelpContext | undefined) => vscode.SignatureHelp | undefined;
    getSelectionRanges: (uri: string, positions: vscode.Position[]) => vscode.SelectionRange[];
    doValidation: (uri: string, options: {
        semantic?: boolean | undefined;
        syntactic?: boolean | undefined;
        suggestion?: boolean | undefined;
        declaration?: boolean | undefined;
    }, cancellationToken?: ts.CancellationToken | undefined) => vscode.Diagnostic[];
    getFoldingRanges: (uri: string) => vscode.FoldingRange[];
    getDocumentSemanticTokens: (uri: string, range?: vscode.Range | undefined, cancle?: vscode.CancellationToken | undefined) => [number, number, number, number, number][] | undefined;
    callHierarchy: {
        doPrepare: (uri: string, position: vscode.Position) => vscode.CallHierarchyItem[];
        getIncomingCalls: (item: vscode.CallHierarchyItem) => vscode.CallHierarchyIncomingCall[];
        getOutgoingCalls: (item: vscode.CallHierarchyItem) => vscode.CallHierarchyOutgoingCall[];
    };
    dispose: () => void;
    __internal__: {
        host: ts.LanguageServiceHost;
        raw: ts.LanguageService;
        getTextDocument: (uri: string) => TextDocument | undefined;
        getValidTextDocument: (uri: string) => TextDocument | undefined;
        isValidFile: (fileName: string) => boolean;
    };
};
