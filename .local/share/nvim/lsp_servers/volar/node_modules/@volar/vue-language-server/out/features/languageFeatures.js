"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.register = void 0;
const shared = require("@volar/shared");
const vue = require("@volar/vue-language-service");
const vscode = require("vscode-languageserver");
const project_1 = require("../project");
const utils_1 = require("../utils");
function register(ts, connection, documents, projects, features, params) {
    connection.onCompletion((handler) => __awaiter(this, void 0, void 0, function* () {
        return worker(handler.textDocument.uri, (vueLs) => __awaiter(this, void 0, void 0, function* () {
            var _a, _b, _c, _d;
            const list = yield vueLs.doComplete(handler.textDocument.uri, handler.position, handler.context);
            const insertReplaceSupport = (_d = (_c = (_b = (_a = params.capabilities.textDocument) === null || _a === void 0 ? void 0 : _a.completion) === null || _b === void 0 ? void 0 : _b.completionItem) === null || _c === void 0 ? void 0 : _c.insertReplaceSupport) !== null && _d !== void 0 ? _d : false;
            if (!insertReplaceSupport && list) {
                for (const item of list.items) {
                    if (item.textEdit && vscode.InsertReplaceEdit.is(item.textEdit)) {
                        item.textEdit = vscode.TextEdit.replace(item.textEdit.insert, item.textEdit.newText);
                    }
                }
            }
            return list;
        }));
    }));
    connection.onCompletionResolve((item) => __awaiter(this, void 0, void 0, function* () {
        var _e, _f, _g, _h, _j, _k, _l;
        const uri = (_e = item.data) === null || _e === void 0 ? void 0 : _e.uri;
        if (!uri) {
            return item;
        }
        const activeSel = ((_f = features.completion) === null || _f === void 0 ? void 0 : _f.getDocumentSelectionRequest)
            ? yield connection.sendRequest(shared.GetEditorSelectionRequest.type)
            : undefined;
        const newPosition = (activeSel === null || activeSel === void 0 ? void 0 : activeSel.textDocument.uri.toLowerCase()) === uri.toLowerCase() ? activeSel.position : undefined;
        const result = (_g = yield worker(uri, (vueLs) => __awaiter(this, void 0, void 0, function* () {
            var _m;
            return (_m = vueLs.doCompletionResolve(item, newPosition)) !== null && _m !== void 0 ? _m : item;
        }))) !== null && _g !== void 0 ? _g : item;
        const insertReplaceSupport = (_l = (_k = (_j = (_h = params.capabilities.textDocument) === null || _h === void 0 ? void 0 : _h.completion) === null || _j === void 0 ? void 0 : _j.completionItem) === null || _k === void 0 ? void 0 : _k.insertReplaceSupport) !== null && _l !== void 0 ? _l : false;
        if (!insertReplaceSupport) {
            if (result.textEdit && vscode.InsertReplaceEdit.is(result.textEdit)) {
                result.textEdit = vscode.TextEdit.replace(result.textEdit.insert, result.textEdit.newText);
            }
        }
        return result;
    }));
    connection.onHover((handler) => __awaiter(this, void 0, void 0, function* () {
        return worker(handler.textDocument.uri, vueLs => {
            return vueLs.doHover(handler.textDocument.uri, handler.position);
        });
    }));
    connection.onSignatureHelp((handler) => __awaiter(this, void 0, void 0, function* () {
        return worker(handler.textDocument.uri, vueLs => {
            return vueLs.getSignatureHelp(handler.textDocument.uri, handler.position, handler.context);
        });
    }));
    connection.onPrepareRename((handler) => __awaiter(this, void 0, void 0, function* () {
        return worker(handler.textDocument.uri, vueLs => {
            return vueLs.prepareRename(handler.textDocument.uri, handler.position);
        });
    }));
    connection.onRenameRequest((handler) => __awaiter(this, void 0, void 0, function* () {
        return worker(handler.textDocument.uri, vueLs => {
            return vueLs.doRename(handler.textDocument.uri, handler.position, handler.newName);
        });
    }));
    connection.onCodeLens((handler) => __awaiter(this, void 0, void 0, function* () {
        return worker(handler.textDocument.uri, vueLs => {
            return vueLs.doCodeLens(handler.textDocument.uri);
        });
    }));
    connection.onCodeLensResolve((codeLens) => __awaiter(this, void 0, void 0, function* () {
        var _o, _p;
        const uri = (_o = codeLens.data) === null || _o === void 0 ? void 0 : _o.uri; // TODO
        if (!uri) {
            return codeLens;
        }
        return (_p = yield worker(uri, vueLs => {
            var _a;
            return (_a = vueLs.doCodeLensResolve(codeLens)) !== null && _a !== void 0 ? _a : codeLens;
        })) !== null && _p !== void 0 ? _p : codeLens;
    }));
    connection.onExecuteCommand((handler, token, workDoneProgress) => __awaiter(this, void 0, void 0, function* () {
        if (handler.command === vue.executePluginCommand) {
            const args = handler.arguments;
            if (!args) {
                return;
            }
            return worker(args[0], vueLs => {
                return vueLs.doExecuteCommand(handler.command, args, {
                    token,
                    workDoneProgress,
                    applyEdit: (paramOrEdit) => connection.workspace.applyEdit(paramOrEdit),
                    sendNotification: (type, params) => connection.sendNotification(type, params),
                });
            });
        }
        if (handler.command === 'volar.server.convertTagNameCasing') {
            const args = handler.arguments;
            if (!args) {
                return;
            }
            return worker(args[0], vueLs => {
                return vueLs.doExecuteCommand(vue.executePluginCommand, [
                    args[0],
                    undefined,
                    vscode.Command.create('', vue.convertTagNameCasingCommand, ...[
                        args[0],
                        args[1],
                    ]),
                ], {
                    token,
                    workDoneProgress,
                    applyEdit: (paramOrEdit) => connection.workspace.applyEdit(paramOrEdit),
                    sendNotification: (type, params) => connection.sendNotification(type, params),
                });
            });
        }
    }));
    connection.onCodeAction((handler) => __awaiter(this, void 0, void 0, function* () {
        return worker(handler.textDocument.uri, (vueLs) => __awaiter(this, void 0, void 0, function* () {
            var _q;
            const codeActions = (_q = yield vueLs.doCodeActions(handler.textDocument.uri, handler.range, handler.context)) !== null && _q !== void 0 ? _q : [];
            for (const codeAction of codeActions) {
                if (codeAction.data && typeof codeAction.data === 'object') {
                    codeAction.data.uri = handler.textDocument.uri;
                }
                else {
                    codeAction.data = { uri: handler.textDocument.uri };
                }
            }
            return codeActions;
        }));
    }));
    connection.onCodeActionResolve((codeAction) => __awaiter(this, void 0, void 0, function* () {
        var _r, _s;
        const uri = (_r = codeAction.data) === null || _r === void 0 ? void 0 : _r.uri;
        if (!uri) {
            return codeAction;
        }
        return (_s = yield worker(uri, vueLs => {
            return vueLs.doCodeActionResolve(codeAction);
        })) !== null && _s !== void 0 ? _s : codeAction;
    }));
    connection.onReferences((handler) => __awaiter(this, void 0, void 0, function* () {
        return worker(handler.textDocument.uri, vueLs => {
            return vueLs.findReferences(handler.textDocument.uri, handler.position);
        });
    }));
    connection.onImplementation((handler) => __awaiter(this, void 0, void 0, function* () {
        return worker(handler.textDocument.uri, vueLs => {
            return vueLs.findImplementations(handler.textDocument.uri, handler.position);
        });
    }));
    connection.onDefinition((handler) => __awaiter(this, void 0, void 0, function* () {
        return worker(handler.textDocument.uri, vueLs => {
            return vueLs.findDefinition(handler.textDocument.uri, handler.position);
        });
    }));
    connection.onTypeDefinition((handler) => __awaiter(this, void 0, void 0, function* () {
        return worker(handler.textDocument.uri, vueLs => {
            return vueLs.findTypeDefinition(handler.textDocument.uri, handler.position);
        });
    }));
    connection.onDocumentHighlight((handler) => __awaiter(this, void 0, void 0, function* () {
        return worker(handler.textDocument.uri, vueLs => {
            return vueLs.findDocumentHighlights(handler.textDocument.uri, handler.position);
        });
    }));
    connection.onDocumentLinks((handler) => __awaiter(this, void 0, void 0, function* () {
        return worker(handler.textDocument.uri, vueLs => {
            return vueLs.findDocumentLinks(handler.textDocument.uri);
        });
    }));
    connection.onWorkspaceSymbol((handler, token) => __awaiter(this, void 0, void 0, function* () {
        let results = [];
        for (const workspace of projects.workspaces.values()) {
            let projects = [...workspace.projects.values()];
            projects = projects.length ? projects : [workspace.getInferredProject()];
            for (const project of projects) {
                if (token.isCancellationRequested)
                    return;
                const vueLs = (yield project).getLanguageService();
                results = results.concat(yield vueLs.findWorkspaceSymbols(handler.query));
            }
        }
        return results;
    }));
    connection.languages.callHierarchy.onPrepare((handler) => __awaiter(this, void 0, void 0, function* () {
        var _t;
        return (_t = yield worker(handler.textDocument.uri, (vueLs) => __awaiter(this, void 0, void 0, function* () {
            const items = yield vueLs.callHierarchy.doPrepare(handler.textDocument.uri, handler.position);
            if (items) {
                for (const item of items) {
                    if (typeof item.data !== 'object')
                        item.data = {};
                    item.data.__uri = handler.textDocument.uri;
                }
            }
            return (items === null || items === void 0 ? void 0 : items.length) ? items : null;
        }))) !== null && _t !== void 0 ? _t : [];
    }));
    connection.languages.callHierarchy.onIncomingCalls((handler) => __awaiter(this, void 0, void 0, function* () {
        var _u, _v;
        const data = handler.item.data;
        const uri = (_u = data === null || data === void 0 ? void 0 : data.__uri) !== null && _u !== void 0 ? _u : handler.item.uri;
        return (_v = yield worker(uri, vueLs => {
            return vueLs.callHierarchy.getIncomingCalls(handler.item);
        })) !== null && _v !== void 0 ? _v : [];
    }));
    connection.languages.callHierarchy.onOutgoingCalls((handler) => __awaiter(this, void 0, void 0, function* () {
        var _w, _x;
        const data = handler.item.data;
        const uri = (_w = data === null || data === void 0 ? void 0 : data.__uri) !== null && _w !== void 0 ? _w : handler.item.uri;
        return (_x = yield worker(uri, vueLs => {
            return vueLs.callHierarchy.getOutgoingCalls(handler.item);
        })) !== null && _x !== void 0 ? _x : [];
    }));
    connection.languages.semanticTokens.on((handler, token, _, resultProgress) => __awaiter(this, void 0, void 0, function* () {
        var _y;
        return (_y = yield worker(handler.textDocument.uri, (vueLs) => __awaiter(this, void 0, void 0, function* () {
            var _z;
            const result = (_z = yield (vueLs === null || vueLs === void 0 ? void 0 : vueLs.getSemanticTokens(handler.textDocument.uri, undefined, token, tokens => resultProgress === null || resultProgress === void 0 ? void 0 : resultProgress.report(buildTokens(tokens))))) !== null && _z !== void 0 ? _z : [];
            return buildTokens(result);
        }))) !== null && _y !== void 0 ? _y : buildTokens([]);
    }));
    connection.languages.semanticTokens.onRange((handler, token, _, resultProgress) => __awaiter(this, void 0, void 0, function* () {
        var _0;
        return (_0 = yield worker(handler.textDocument.uri, (vueLs) => __awaiter(this, void 0, void 0, function* () {
            var _1;
            const result = (_1 = yield (vueLs === null || vueLs === void 0 ? void 0 : vueLs.getSemanticTokens(handler.textDocument.uri, handler.range, token, tokens => resultProgress === null || resultProgress === void 0 ? void 0 : resultProgress.report(buildTokens(tokens))))) !== null && _1 !== void 0 ? _1 : [];
            return buildTokens(result);
        }))) !== null && _0 !== void 0 ? _0 : buildTokens([]);
    }));
    connection.languages.inlayHint.on((handler) => __awaiter(this, void 0, void 0, function* () {
        return worker(handler.textDocument.uri, vueLs => {
            return vueLs.getInlayHints(handler.textDocument.uri, handler.range);
        });
    }));
    connection.workspace.onWillRenameFiles((handler) => __awaiter(this, void 0, void 0, function* () {
        const hasTsFile = handler.files.some(file => file.newUri.endsWith('.vue') || file.newUri.endsWith('.ts') || file.newUri.endsWith('.tsx'));
        const config = yield connection.workspace.getConfiguration(hasTsFile ? 'typescript.updateImportsOnFileMove.enabled' : 'javascript.updateImportsOnFileMove.enabled');
        if (config === 'always') {
            const renaming = new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
                var _2, _3;
                for (const file of handler.files) {
                    const renameFileContent = (0, project_1.getScriptText)(documents, shared.uriToFsPath(file.oldUri), ts.sys);
                    if (renameFileContent) {
                        project_1.renameFileContentCache.set(file.oldUri, renameFileContent);
                    }
                }
                yield shared.sleep(0);
                const edit = yield worker();
                if (edit) {
                    if (edit.documentChanges) {
                        for (const change of edit.documentChanges) {
                            if (vscode.TextDocumentEdit.is(change)) {
                                for (const file of handler.files) {
                                    if (change.textDocument.uri === file.oldUri) {
                                        change.textDocument.uri = file.newUri;
                                        change.textDocument.version = (_3 = (_2 = (0, utils_1.getDocumentSafely)(documents, file.newUri)) === null || _2 === void 0 ? void 0 : _2.version) !== null && _3 !== void 0 ? _3 : change.textDocument.version;
                                    }
                                }
                            }
                        }
                    }
                    connection.workspace.applyEdit(edit);
                }
                resolve();
            }));
            project_1.fileRenamings.add(renaming);
            (() => __awaiter(this, void 0, void 0, function* () {
                yield renaming;
                project_1.fileRenamings.delete(renaming);
                project_1.renameFileContentCache.clear();
            }))();
        }
        if (config === 'prompt')
            return yield worker();
        return null;
        function worker() {
            return __awaiter(this, void 0, void 0, function* () {
                const edits = (yield Promise.all(handler.files
                    .map((file) => __awaiter(this, void 0, void 0, function* () {
                    const vueLs = yield getLanguageService(file.oldUri);
                    return vueLs === null || vueLs === void 0 ? void 0 : vueLs.getEditsForFileRename(file.oldUri, file.newUri);
                })))).filter(shared.notEmpty);
                if (edits.length) {
                    const result = edits[0];
                    vue.mergeWorkspaceEdits(result, ...edits.slice(1));
                    return result;
                }
                return null;
            });
        }
    }));
    connection.onRequest(shared.AutoInsertRequest.type, (handler) => __awaiter(this, void 0, void 0, function* () {
        return worker(handler.textDocument.uri, vueLs => {
            return vueLs.doAutoInsert(handler.textDocument.uri, handler.position, handler.options);
        });
    }));
    function worker(uri, cb) {
        return __awaiter(this, void 0, void 0, function* () {
            const vueLs = yield getLanguageService(uri);
            if (vueLs) {
                return cb(vueLs);
            }
        });
    }
    function buildTokens(tokens) {
        const builder = new vscode.SemanticTokensBuilder();
        const sortedTokens = tokens.sort((a, b) => a[0] - b[0] === 0 ? a[1] - b[1] : a[0] - b[0]);
        for (const token of sortedTokens) {
            builder.push(...token);
        }
        return builder.build();
    }
    function getLanguageService(uri) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const project = (_a = (yield projects.getProject(uri))) === null || _a === void 0 ? void 0 : _a.project;
            return project === null || project === void 0 ? void 0 : project.getLanguageService();
        });
    }
}
exports.register = register;
//# sourceMappingURL=languageFeatures.js.map