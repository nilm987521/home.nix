"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.useCacheMap = exports.parseVueDocument = exports.parseVueDocuments = exports.TeleportSourceMap = exports.EmbeddedDocumentSourceMap = exports.SourceMap = void 0;
const vue_typescript_1 = require("@volar/vue-typescript");
const shared = require("@volar/shared");
const reactivity_1 = require("@vue/reactivity");
const source_map_1 = require("@volar/source-map");
const vscode_languageserver_textdocument_1 = require("vscode-languageserver-textdocument");
const untrack_1 = require("./utils/untrack");
class SourceMap extends source_map_1.SourceMapBase {
    constructor(sourceDocument, mappedDocument, _mappings) {
        super(_mappings);
        this.sourceDocument = sourceDocument;
        this.mappedDocument = mappedDocument;
        this._mappings = _mappings;
    }
    getSourceRange(start, end, filter) {
        for (const mapped of this.getRanges(start, end !== null && end !== void 0 ? end : start, false, filter)) {
            return mapped;
        }
    }
    getMappedRange(start, end, filter) {
        for (const mapped of this.getRanges(start, end !== null && end !== void 0 ? end : start, true, filter)) {
            return mapped;
        }
    }
    getSourceRanges(start, end, filter) {
        return this.getRanges(start, end !== null && end !== void 0 ? end : start, false, filter);
    }
    getMappedRanges(start, end, filter) {
        return this.getRanges(start, end !== null && end !== void 0 ? end : start, true, filter);
    }
    *getRanges(start, end, sourceToTarget, filter) {
        const startIsNumber = typeof start === 'number';
        const endIsNumber = typeof end === 'number';
        const toDoc = sourceToTarget ? this.mappedDocument : this.sourceDocument;
        const fromDoc = sourceToTarget ? this.sourceDocument : this.mappedDocument;
        const startOffset = startIsNumber ? start : fromDoc.offsetAt(start);
        const endOffset = endIsNumber ? end : fromDoc.offsetAt(end);
        for (const mapped of super.getRanges(startOffset, endOffset, sourceToTarget, filter)) {
            yield getMapped(mapped);
        }
        function getMapped(mapped) {
            if (startIsNumber) {
                return mapped;
            }
            return [{
                    start: toDoc.positionAt(mapped[0].start),
                    end: toDoc.positionAt(mapped[0].end),
                }, mapped[1]];
        }
    }
}
exports.SourceMap = SourceMap;
class EmbeddedDocumentSourceMap extends SourceMap {
    constructor(embeddedFile, sourceDocument, mappedDocument, _sourceMap) {
        super(sourceDocument, mappedDocument, _sourceMap.mappings);
        this.embeddedFile = embeddedFile;
        this.sourceDocument = sourceDocument;
        this.mappedDocument = mappedDocument;
    }
}
exports.EmbeddedDocumentSourceMap = EmbeddedDocumentSourceMap;
class TeleportSourceMap extends SourceMap {
    constructor(embeddedFile, document, teleport) {
        super(document, document, teleport.mappings);
        this.embeddedFile = embeddedFile;
        this.document = document;
    }
    *findTeleports(start, end, filter) {
        for (const [teleRange, data] of this.getMappedRanges(start, end, filter ? data => filter(data.toTarget) : undefined)) {
            yield [teleRange, data.toTarget];
        }
        for (const [teleRange, data] of this.getSourceRanges(start, end, filter ? data => filter(data.toSource) : undefined)) {
            yield [teleRange, data.toSource];
        }
    }
}
exports.TeleportSourceMap = TeleportSourceMap;
function parseVueDocuments(vueFiles) {
    // cache map
    const vueDocuments = useCacheMap(vueFile => {
        return parseVueDocument(vueFile);
    });
    // reactivity
    const embeddedDocumentsMap = (0, reactivity_1.computed)(() => {
        const map = new Map();
        for (const vueDocument of getAll()) {
            for (const sourceMap of vueDocument.refs.sourceMaps.value) {
                map.set(sourceMap.mappedDocument, vueDocument);
            }
        }
        return map;
    });
    const embeddedDocumentsMapLsType = (0, reactivity_1.computed)(() => {
        const map = new Map();
        for (const vueDocument of getAll()) {
            for (const sourceMap of vueDocument.refs.sourceMaps.value) {
                map.set(sourceMap.mappedDocument.uri, sourceMap);
            }
        }
        return map;
    });
    const teleportsMapLsType = (0, reactivity_1.computed)(() => {
        const map = new Map();
        for (const vueDocument of getAll()) {
            for (const teleport of vueDocument.refs.teleports.value) {
                map.set(teleport.mappedDocument.uri, teleport);
            }
        }
        return map;
    });
    return {
        getAll: (0, untrack_1.untrack)(getAll),
        get: (0, untrack_1.untrack)((uri) => {
            const fileName = shared.uriToFsPath(uri);
            const vueFile = vueFiles.get(fileName);
            if (vueFile) {
                return vueDocuments.get(vueFile);
            }
        }),
        fromEmbeddedDocument: (0, untrack_1.untrack)((document) => {
            return embeddedDocumentsMap.value.get(document);
        }),
        sourceMapFromEmbeddedDocumentUri: (0, untrack_1.untrack)((uri) => {
            return embeddedDocumentsMapLsType.value.get(uri);
        }),
        teleportfromEmbeddedDocumentUri: (0, untrack_1.untrack)((uri) => {
            return teleportsMapLsType.value.get(uri);
        }),
        fromEmbeddedLocation: (0, untrack_1.untrack)(function* (uri, start, end, filter, sourceMapFilter) {
            if (uri.endsWith(`/${vue_typescript_1.localTypes.typesFileName}`))
                return;
            if (end === undefined)
                end = start;
            const sourceMap = embeddedDocumentsMapLsType.value.get(uri);
            if (sourceMap) {
                if (sourceMapFilter && !sourceMapFilter(sourceMap))
                    return;
                for (const vueRange of sourceMap.getSourceRanges(start, end, filter)) {
                    yield {
                        uri: sourceMap.sourceDocument.uri,
                        range: vueRange[0],
                        sourceMap,
                        data: vueRange[1],
                    };
                }
            }
            else {
                yield {
                    uri,
                    range: {
                        start,
                        end,
                    },
                };
            }
        }),
    };
    function getAll() {
        return vueFiles.getAll().map(vueFile => vueDocuments.get(vueFile));
    }
}
exports.parseVueDocuments = parseVueDocuments;
function parseVueDocument(vueFile) {
    // cache map
    let documentVersion = 0;
    const embeddedDocumentVersions = new Map();
    const embeddedDocumentsMap = useCacheMap(embeddedFile => {
        var _a;
        const uri = shared.fsPathToUri(embeddedFile.fileName);
        const newVersion = ((_a = embeddedDocumentVersions.get(uri.toLowerCase())) !== null && _a !== void 0 ? _a : 0) + 1;
        embeddedDocumentVersions.set(uri.toLowerCase(), newVersion);
        return vscode_languageserver_textdocument_1.TextDocument.create(uri, shared.syntaxToLanguageId(embeddedFile.lang), newVersion, embeddedFile.content);
    });
    const sourceMapsMap = useCacheMap(embedded => {
        return new EmbeddedDocumentSourceMap(embedded.file, document.value, embeddedDocumentsMap.get(embedded.file), embedded.sourceMap);
    });
    // reactivity
    const document = (0, reactivity_1.computed)(() => vscode_languageserver_textdocument_1.TextDocument.create(shared.fsPathToUri(vueFile.fileName), 'vue', documentVersion++, vueFile.refs.content.value));
    const sourceMaps = (0, reactivity_1.computed)(() => {
        return vueFile.refs.allEmbeddeds.value.map(embedded => sourceMapsMap.get(embedded));
    });
    const teleports = (0, reactivity_1.computed)(() => {
        return vueFile.refs.teleports.value.map(teleportAndFile => {
            const embeddedDocument = embeddedDocumentsMap.get(teleportAndFile.file);
            const sourceMap = new TeleportSourceMap(teleportAndFile.file, embeddedDocument, teleportAndFile.teleport);
            return sourceMap;
        });
    });
    return {
        uri: shared.fsPathToUri(vueFile.fileName),
        file: vueFile,
        embeddedDocumentsMap,
        sourceMapsMap,
        getSourceMaps: (0, untrack_1.untrack)(() => sourceMaps.value),
        getDocument: (0, untrack_1.untrack)(() => document.value),
        refs: {
            sourceMaps,
            teleports,
        },
    };
}
exports.parseVueDocument = parseVueDocument;
function useCacheMap(parse) {
    const cache = new WeakMap();
    return {
        get,
    };
    function get(source) {
        let result = cache.get(source);
        if (!result) {
            result = parse(source);
            cache.set(source, result);
        }
        return result;
    }
}
exports.useCacheMap = useCacheMap;
//# sourceMappingURL=vueDocuments.js.map