"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.register = void 0;
const shared = require("@volar/shared");
const upath = require("upath");
const dedupe = require("../utils/dedupe");
const featureWorkers_1 = require("../utils/featureWorkers");
function register(context) {
    return {
        doPrepare(uri, position) {
            return (0, featureWorkers_1.languageFeatureWorker)(context, uri, position, function* (position, sourceMap) {
                for (const [mappedRange] of sourceMap.getMappedRanges(position, position, data => !!data.capabilities.references)) {
                    yield mappedRange.start;
                }
            }, (plugin, document, position, sourceMap) => __awaiter(this, void 0, void 0, function* () {
                var _a;
                const items = yield ((_a = plugin.callHierarchy) === null || _a === void 0 ? void 0 : _a.prepare(document, position));
                return items === null || items === void 0 ? void 0 : items.map(item => {
                    const data = {
                        uri,
                        originalItem: item,
                        pluginId: context.getPluginId(plugin),
                        sourceMap: sourceMap ? {
                            embeddedDocumentUri: sourceMap.mappedDocument.uri,
                        } : undefined,
                    };
                    return Object.assign(Object.assign({}, item), { data: data });
                });
            }), (data, sourceMap) => !sourceMap ? data : data
                .map(item => { var _a; return (_a = transformCallHierarchyItem(item, [])) === null || _a === void 0 ? void 0 : _a[0]; })
                .filter(shared.notEmpty), arr => dedupe.withLocations(arr.flat()));
        },
        getIncomingCalls(item) {
            return __awaiter(this, void 0, void 0, function* () {
                const data = item.data;
                let incomingItems = [];
                if (data) {
                    const plugin = context.getPluginById(data.pluginId);
                    if (!plugin)
                        return incomingItems;
                    if (!plugin.callHierarchy)
                        return incomingItems;
                    const originalItem = data.originalItem;
                    if (data.sourceMap) {
                        const sourceMap = context.vueDocuments.sourceMapFromEmbeddedDocumentUri(data.sourceMap.embeddedDocumentUri);
                        if (sourceMap) {
                            const _calls = yield plugin.callHierarchy.onIncomingCalls(originalItem);
                            for (const _call of _calls) {
                                const calls = transformCallHierarchyItem(_call.from, _call.fromRanges);
                                if (!calls)
                                    continue;
                                incomingItems.push({
                                    from: calls[0],
                                    fromRanges: calls[1],
                                });
                            }
                        }
                    }
                    else {
                        const _calls = yield plugin.callHierarchy.onIncomingCalls(item);
                        for (const _call of _calls) {
                            const calls = transformCallHierarchyItem(_call.from, _call.fromRanges);
                            if (!calls)
                                continue;
                            incomingItems.push({
                                from: calls[0],
                                fromRanges: calls[1],
                            });
                        }
                    }
                }
                return dedupe.withCallHierarchyIncomingCalls(incomingItems);
            });
        },
        getOutgoingCalls(item) {
            return __awaiter(this, void 0, void 0, function* () {
                const data = item.data;
                let items = [];
                if (data) {
                    const plugin = context.getPluginById(data.pluginId);
                    if (!plugin)
                        return items;
                    if (!plugin.callHierarchy)
                        return items;
                    const originalItem = data.originalItem;
                    if (data.sourceMap) {
                        const sourceMap = context.vueDocuments.sourceMapFromEmbeddedDocumentUri(data.sourceMap.embeddedDocumentUri);
                        if (sourceMap) {
                            const _calls = yield plugin.callHierarchy.onOutgoingCalls(originalItem);
                            for (const call of _calls) {
                                const calls = transformCallHierarchyItem(call.to, call.fromRanges);
                                if (!calls)
                                    continue;
                                items.push({
                                    to: calls[0],
                                    fromRanges: calls[1],
                                });
                            }
                        }
                    }
                    else {
                        const _calls = yield plugin.callHierarchy.onOutgoingCalls(item);
                        for (const call of _calls) {
                            const calls = transformCallHierarchyItem(call.to, call.fromRanges);
                            if (!calls)
                                continue;
                            items.push({
                                to: calls[0],
                                fromRanges: calls[1],
                            });
                        }
                    }
                }
                return dedupe.withCallHierarchyOutgoingCalls(items);
            });
        },
    };
    function transformCallHierarchyItem(tsItem, tsRanges) {
        var _a, _b;
        const sourceMap = context.vueDocuments.sourceMapFromEmbeddedDocumentUri(tsItem.uri);
        if (!sourceMap)
            return [tsItem, tsRanges]; // not virtual file
        let vueRange = (_a = sourceMap.getSourceRange(tsItem.range.start, tsItem.range.end)) === null || _a === void 0 ? void 0 : _a[0];
        if (!vueRange) {
            // TODO: <script> range
            vueRange = {
                start: sourceMap.sourceDocument.positionAt(0),
                end: sourceMap.sourceDocument.positionAt(sourceMap.sourceDocument.getText().length),
            };
        }
        const vueSelectionRange = (_b = sourceMap.getSourceRange(tsItem.selectionRange.start, tsItem.selectionRange.end)) === null || _b === void 0 ? void 0 : _b[0];
        if (!vueSelectionRange)
            return;
        const vueRanges = tsRanges.map(tsRange => { var _a; return (_a = sourceMap.getSourceRange(tsRange.start, tsRange.end)) === null || _a === void 0 ? void 0 : _a[0]; }).filter(shared.notEmpty);
        const vueItem = Object.assign(Object.assign({}, tsItem), { name: tsItem.name === upath.basename(shared.uriToFsPath(sourceMap.mappedDocument.uri)) ? upath.basename(shared.uriToFsPath(sourceMap.sourceDocument.uri)) : tsItem.name, uri: sourceMap.sourceDocument.uri, range: vueRange, selectionRange: vueSelectionRange });
        return [vueItem, vueRanges];
    }
}
exports.register = register;
//# sourceMappingURL=callHierarchy.js.map