"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getScriptText = exports.createProject = exports.renameFileContentCache = exports.fileRenamings = void 0;
const shared = require("@volar/shared");
const vue = require("@volar/vue-language-service");
const vscode = require("vscode-languageserver");
const path = require("upath");
const utils_1 = require("./utils");
const common_1 = require("./common");
const vue_typescript_1 = require("@volar/vue-typescript");
exports.fileRenamings = new Set();
exports.renameFileContentCache = new Map();
function createProject(runtimeEnv, ts, options, rootPath, tsConfig, tsLocalized, documents, connection, lsConfigs) {
    return __awaiter(this, void 0, void 0, function* () {
        yield Promise.all([...exports.fileRenamings]);
        const projectSys = Object.assign(Object.assign({}, ts.sys), { readFile: (path, encoding) => ts.sys.readFile(resolveAbsolutePath(path), encoding), writeFile: (path, content) => ts.sys.writeFile(resolveAbsolutePath(path), content), directoryExists: path => {
                if (path === '') {
                    // fix https://github.com/johnsoncodehk/volar/issues/679
                    return ts.sys.directoryExists(path);
                }
                return ts.sys.directoryExists(resolveAbsolutePath(path));
            }, getDirectories: path => ts.sys.getDirectories(resolveAbsolutePath(path)), readDirectory: (path, extensions, exclude, include, depth) => ts.sys.readDirectory(resolveAbsolutePath(path), extensions, exclude, include, depth), realpath: ts.sys.realpath ? path => {
                const resolvedPath = resolveAbsolutePath(path);
                const realPath = ts.sys.realpath(resolvedPath);
                if (realPath === resolvedPath) {
                    // rollback if failed
                    return path;
                }
                return realPath;
            } : undefined, fileExists: path => ts.sys.fileExists(resolveAbsolutePath(path)), getCurrentDirectory: () => rootPath });
        let typeRootVersion = 0;
        let projectVersion = 0;
        let vueLs;
        let parsedCommandLine = createParsedCommandLine();
        const scripts = shared.createPathMap();
        const languageServiceHost = createLanguageServiceHost();
        return {
            onWorkspaceFilesChanged,
            onDocumentUpdated,
            getLanguageService,
            getLanguageServiceDontCreate: () => vueLs,
            getParsedCommandLine: () => parsedCommandLine,
            dispose,
        };
        function resolveAbsolutePath(_path) {
            const relativePath = path.relative(ts.sys.getCurrentDirectory(), rootPath);
            if (relativePath === '')
                return _path;
            if (_path === '')
                return relativePath;
            return !path.isAbsolute(_path) ? relativePath + '/' + _path : _path;
        }
        function getLanguageService() {
            var _a;
            if (!vueLs) {
                vueLs = vue.createLanguageService({ typescript: ts }, languageServiceHost, runtimeEnv.fileSystemProvide, (uri) => {
                    var _a;
                    const protocol = uri.substring(0, uri.indexOf(':'));
                    const builtInHandler = runtimeEnv.schemaRequestHandlers[protocol];
                    if (builtInHandler) {
                        return builtInHandler(uri);
                    }
                    if (typeof options === 'object' && ((_a = options.languageFeatures) === null || _a === void 0 ? void 0 : _a.schemaRequestService)) {
                        return connection.sendRequest(shared.GetDocumentContentRequest.type, { uri }).then(responseText => {
                            return responseText;
                        }, error => {
                            return Promise.reject(error.message);
                        });
                    }
                    else {
                        return Promise.reject('clientHandledGetDocumentContentRequest is false');
                    }
                }, lsConfigs, (0, common_1.loadCustomPlugins)(languageServiceHost.getCurrentDirectory()), ((_a = options.languageFeatures) === null || _a === void 0 ? void 0 : _a.completion) ? (uri) => __awaiter(this, void 0, void 0, function* () {
                    var _b, _c;
                    if ((_c = (_b = options.languageFeatures) === null || _b === void 0 ? void 0 : _b.completion) === null || _c === void 0 ? void 0 : _c.getDocumentNameCasesRequest) {
                        const res = yield connection.sendRequest(shared.GetDocumentNameCasesRequest.type, { uri });
                        return {
                            tag: res.tagNameCase,
                            attr: res.attrNameCase,
                        };
                    }
                    return {
                        tag: options.languageFeatures.completion.defaultTagNameCase,
                        attr: options.languageFeatures.completion.defaultAttrNameCase,
                    };
                }) : undefined);
            }
            return vueLs;
        }
        function onWorkspaceFilesChanged(changes) {
            return __awaiter(this, void 0, void 0, function* () {
                yield Promise.all([...exports.fileRenamings]);
                for (const change of changes) {
                    const script = scripts.uriGet(change.uri);
                    if (script && (change.type === vscode.FileChangeType.Changed || change.type === vscode.FileChangeType.Created)) {
                        if (script.version >= 0) {
                            script.version = -1;
                        }
                        else {
                            script.version--;
                        }
                    }
                    else if (script && change.type === vscode.FileChangeType.Deleted) {
                        scripts.uriDelete(change.uri);
                    }
                    projectVersion++;
                }
                const creates = changes.filter(change => change.type === vscode.FileChangeType.Created);
                const deletes = changes.filter(change => change.type === vscode.FileChangeType.Deleted);
                if (creates.length || deletes.length) {
                    parsedCommandLine = createParsedCommandLine();
                    typeRootVersion++; // TODO: check changed in node_modules?
                }
            });
        }
        function onDocumentUpdated(document) {
            return __awaiter(this, void 0, void 0, function* () {
                yield Promise.all([...exports.fileRenamings]);
                const script = scripts.uriGet(document.uri);
                if (script) {
                    script.version = document.version;
                }
                projectVersion++;
            });
        }
        function createLanguageServiceHost() {
            const host = {
                // ts
                getNewLine: () => projectSys.newLine,
                useCaseSensitiveFileNames: () => projectSys.useCaseSensitiveFileNames,
                readFile: projectSys.readFile,
                writeFile: projectSys.writeFile,
                directoryExists: projectSys.directoryExists,
                getDirectories: projectSys.getDirectories,
                readDirectory: projectSys.readDirectory,
                realpath: projectSys.realpath,
                fileExists: projectSys.fileExists,
                getCurrentDirectory: projectSys.getCurrentDirectory,
                getProjectReferences: () => parsedCommandLine.projectReferences,
                // custom
                getDefaultLibFileName: options => ts.getDefaultLibFilePath(options),
                getProjectVersion: () => projectVersion.toString(),
                getTypeRootsVersion: () => typeRootVersion,
                getScriptFileNames: () => {
                    const fileNames = new Set(parsedCommandLine.fileNames);
                    for (const script of scripts.values()) {
                        fileNames.add(script.fileName);
                    }
                    return [...fileNames];
                },
                getCompilationSettings: () => parsedCommandLine.options,
                getVueCompilationSettings: () => parsedCommandLine.vueOptions,
                getScriptVersion,
                getScriptSnapshot,
            };
            if (tsLocalized) {
                host.getLocalizedDiagnosticMessages = () => tsLocalized;
            }
            return host;
            function getScriptVersion(fileName) {
                var _a, _b;
                return (_b = (_a = scripts.fsPathGet(fileName)) === null || _a === void 0 ? void 0 : _a.version.toString()) !== null && _b !== void 0 ? _b : '';
            }
            function getScriptSnapshot(fileName) {
                const script = scripts.fsPathGet(fileName);
                if (script && script.snapshotVersion === script.version) {
                    return script.snapshot;
                }
                const text = getScriptText(documents, fileName, projectSys);
                if (text !== undefined) {
                    const snapshot = ts.ScriptSnapshot.fromString(text);
                    if (script) {
                        script.snapshot = snapshot;
                        script.snapshotVersion = script.version;
                    }
                    else {
                        scripts.fsPathSet(fileName, {
                            version: -1,
                            fileName: fileName,
                            snapshot: snapshot,
                            snapshotVersion: -1,
                        });
                    }
                    return snapshot;
                }
            }
        }
        function dispose() {
            vueLs === null || vueLs === void 0 ? void 0 : vueLs.dispose();
            scripts.clear();
        }
        function createParsedCommandLine() {
            const parseConfigHost = {
                useCaseSensitiveFileNames: projectSys.useCaseSensitiveFileNames,
                readDirectory: (path, extensions, exclude, include, depth) => {
                    return projectSys.readDirectory(path, [...extensions, '.vue'], exclude, include, depth);
                },
                fileExists: projectSys.fileExists,
                readFile: projectSys.readFile,
            };
            if (typeof tsConfig === 'string') {
                return vue_typescript_1.tsShared.createParsedCommandLine(ts, parseConfigHost, tsConfig);
            }
            else {
                const content = ts.parseJsonConfigFileContent({}, parseConfigHost, rootPath, tsConfig, 'tsconfig.json');
                content.options.outDir = undefined; // TODO: patching ts server broke with outDir + rootDir + composite/incremental
                content.fileNames = content.fileNames.map(shared.normalizeFileName);
                return Object.assign(Object.assign({}, content), { vueOptions: {} });
            }
        }
    });
}
exports.createProject = createProject;
function getScriptText(documents, fileName, sys) {
    const uri = shared.fsPathToUri(fileName);
    const doc = (0, utils_1.getDocumentSafely)(documents, uri);
    if (doc) {
        return doc.getText();
    }
    if (sys.fileExists(fileName)) {
        return sys.readFile(fileName, 'utf8');
    }
    return exports.renameFileContentCache.get(shared.fsPathToUri(fileName));
}
exports.getScriptText = getScriptText;
//# sourceMappingURL=project.js.map